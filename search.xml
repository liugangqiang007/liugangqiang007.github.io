<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[const/static/extern的使用]]></title>
      <url>http://liugangqiang.com/2017/05/19/const-static-extern%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="const-与宏的区别"><a href="#const-与宏的区别" class="headerlink" title="const 与宏的区别"></a>const 与宏的区别</h2><ul>
<li><code>编译时刻</code>:宏是预编译（编译之前处理），const是编译阶段。</li>
<li><code>编译检查</code>:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。</li>
<li><code>宏的好处</code>:宏能定义一些函数，方法。 const不能。</li>
<li><code>宏的坏处</code>:使用大量宏，容易造成编译时间久，每次都需要重新替换。</li>
</ul>
<blockquote>
<p>   注意：使用宏，并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见的常量，使用宏替换</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GGAccount @<span class="string">"accunt"</span></span></span><br><span class="line"><span class="comment">// 字符串常量</span></span><br><span class="line"><span class="keyword">static</span> NSString * <span class="keyword">const</span> account = @<span class="string">"accunt"</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSString *acc = GGAccount;</span><br><span class="line">    NSLog(@<span class="string">"acc:    %p---%p---%@"</span>, acc, &amp;acc, acc.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"account:%p---%p---%@"</span>, account, &amp;account, account.<span class="keyword">class</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">acc:    <span class="number">0x1084f9078</span>--<span class="number">-0x7ffee7705fe8</span>---__NSCFConstantString</span><br><span class="line">account:<span class="number">0x1084f9078</span>--<span class="number">-0x1084f9070</span>---__NSCFConstantString</span><br><span class="line"><span class="comment">// 变量 acc 和常量 account 指向的是同一块内存区域，即字符串常量 @"accunt" 所在的内存地址</span></span><br><span class="line"><span class="comment">// account 被 const 修饰，所以是常量，内存在常量区</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="const-作用：限制类型"><a href="#const-作用：限制类型" class="headerlink" title="const 作用：限制类型"></a>const 作用：限制类型</h2><ul>
<li><code>const</code>仅仅用来修饰右边的变量（基本数据变量p，指针变量*p）</li>
<li>被<code>const</code>修饰的变量是只读的。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; 		<span class="comment">// 定义变量</span></span><br><span class="line">a = <span class="number">100</span>;    		<span class="comment">// 允许修改值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b的值不允许修改，这两种写法作用相同</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// b = 10;			// 不允许修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const:修饰指针变量*p，带*的变量，就是指针变量.</span></span><br><span class="line"><span class="comment">// 定义一个 const 修饰的指针变量，const修饰的是 *p，即 p 访问的内存空间</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a; </span><br><span class="line"><span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">p = &amp;c;			   <span class="comment">// 允许修改 p 的值，即所指向的地址</span></span><br><span class="line"><span class="comment">// *p = 20;		   // 不允许修改 p 访问的内存空间的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const:修饰指针变量 p1</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p1 = &amp;a; <span class="comment">// const修饰的是 p，即 p 自身的内存空间</span></span><br><span class="line"><span class="comment">// p1 = &amp;c;			 // 不允许修改 p 的值，即所指向的地址</span></span><br><span class="line">*p1 = <span class="number">30</span>;			 <span class="comment">// 可以修改 p 访问的内存空间的值</span></span><br></pre></td></tr></table></figure>
<h2 id="static-作用"><a href="#static-作用" class="headerlink" title="static 作用"></a>static 作用</h2><ul>
<li>修饰局部变量：<ol>
<li>延长局部变量的生命周期，程序结束才会销毁。</li>
<li>局部变量只会生成一份内存，只会初始化一次。</li>
<li>改变局部变量的作用域。</li>
</ol>
</li>
<li>修饰全局变量<ol>
<li>只能在本文件中访问，修改全局变量的作用域，生命周期不会改</li>
<li>避免多个同名全局变量重复定义引发冲突</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static 修饰全局变量，只能在本文件中访问，生命周期不会改</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static 修饰局部变量</span></span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">        age++;</span><br><span class="line">        NSLog(@<span class="string">"%d----%p"</span>,age, &amp;age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果，可以看出 age 只初始化了一次，存在一份内存，每次循环使用的都是同一个变量</span></span><br><span class="line"><span class="number">1</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">2</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">3</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">4</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">5</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">6</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">7</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">8</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">9</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">10</span>---<span class="number">-0x1018e3f80</span></span><br></pre></td></tr></table></figure>
<h2 id="extern-作用"><a href="#extern-作用" class="headerlink" title="extern 作用"></a>extern 作用</h2><ul>
<li><p>只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量</p>
</li>
<li><p>先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个 .m 文件定义一个全局变量</span></span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个文件中，使用 extern 可以访问到这个变量</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">     [super viewDidLoad];</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">extern</span> <span class="keyword">int</span> p;</span><br><span class="line">     NSLog(@<span class="string">"%d"</span>,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="static-与-const-组合使用"><a href="#static-与-const-组合使用" class="headerlink" title="static 与 const 组合使用"></a>static 与 const 组合使用</h2><ul>
<li><p>作用：<code>static</code>与<code>const</code>组合可声明一个只读的静态变量</p>
</li>
<li><p>使用场景：在<code>一个文件中</code>经常使用的字符串常量，定义成静态全局只读变量，可以使用<code>static</code>与<code>const</code>组合。如：Cell 的 ReuseIdentifier </p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开发中常用 static 修饰全局变量，只改变作用域，防止重复声明全局变量</span></span><br><span class="line"><span class="comment">// 开发中声明的全局变量，有些不希望外界改动，只允许读取。</span></span><br><span class="line"><span class="comment">// 比如一个基本数据类型不希望别人改动</span></span><br><span class="line"><span class="comment">// 声明一个静态的全局只读常量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开发中经常拿到 key 修改值，因此用 const 修饰 key，表示 key 只读，不允许修改。</span></span><br><span class="line"><span class="keyword">static</span> NSString * <span class="keyword">const</span> key = @<span class="string">"name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cell 的重用字符串，每次获取 cell 时都会使用，创建一个静态常量，避免反复创建</span></span><br><span class="line"><span class="keyword">static</span> NSString * <span class="keyword">const</span> cellIdentifier = @<span class="string">"cellIdentifier"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="extern-与-const-组合使用"><a href="#extern-与-const-组合使用" class="headerlink" title="extern 与 const 组合使用"></a>extern 与 const 组合使用</h2><ul>
<li><p>作用：<code>extern</code>与<code>const</code>组合，只需要定义一份全局变量，多个文件共享。</p>
</li>
<li><p>使用场景：在<code>多个文件中</code>经常使用的同一个字符串常量，可以使用<code>extern</code>与<code>const</code>组合</p>
</li>
<li><p>全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个<code>GlobeConst</code>文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">extern</span> NSString * <span class="keyword">const</span> nameKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line">NSString * <span class="keyword">const</span> nameKey = @<span class="string">"name"</span>;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS内存分布]]></title>
      <url>http://liugangqiang.com/2017/05/18/iOS%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</url>
      <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p><strong>随机存取存储器</strong>（random access memory，RAM）又称作“<a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8" target="_blank" rel="external">随机存储器</a>”，是与CPU直接交换数据的内部存储器，也叫主存(内存)。</p>
<ul>
<li>存储单元的内容可按需随意取出或存入，且存取的速度很快，与存储单元的位置无关。</li>
<li>这种存储器在断电时将丢失其存储内容，故主要用于存储 <em>短时间使用</em> 的程序。</li>
<li>通常作为操作系统或其他正在运行中的程序的临时数据存储媒介。</li>
</ul>
<h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>ROM是<a href="https://baike.baidu.com/item/%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8" target="_blank" rel="external">只读存储器</a>（Read-Only Memory）的简称，是一种只能读出事先所存数据的固态半导体存储器。</p>
<ul>
<li>所存数据稳定，断电后所存数据也不会改变。</li>
<li>其结构较简单，读出较方便，因而常用于存储各种固定程序和数据。</li>
<li>为便于使用和大批量生产，进一步发展了各种可读写存储器，如快闪存储器(Flash memory)。</li>
</ul>
<p>在计算机系统运行应用时，会把APP从ROM里面拷贝到内存（RAM），然后从内存里面执行代码。运行的应用程序的数据都是保存在内存中的，不同类型的数据，保存的内存区域不同。</p>
<a id="more"></a>
<h1 id="iOS的内存"><a href="#iOS的内存" class="headerlink" title="iOS的内存"></a>iOS的内存</h1><p>iOS的内存分布与C语言的类似，分为：</p>
<ol>
<li>代码区</li>
<li>文字常量区</li>
<li>全局区/静态区(Static）</li>
<li>堆区(Heap)</li>
<li>栈区(Stack)</li>
</ol>
<h2 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h2><p>存放函数的二进制代码</p>
<h2 id="常量区"><a href="#常量区" class="headerlink" title="常量区"></a>常量区</h2><p>存放常量字符串以及其他定义的常量，程序结束系统释放</p>
<h2 id="全局区-静态区-Static）"><a href="#全局区-静态区-Static）" class="headerlink" title="全局区/静态区(Static）"></a>全局区/静态区(Static）</h2><p>全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后由系统释放。</p>
<blockquote>
<p>注意：全局区又可分为：</p>
<p>未初始化全局区： bss段</p>
<p>初始化全局区：data段</p>
<p>举例：int a——未初始化的；int a = 10——已初始化的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p;    <span class="comment">// 全局未初始化区</span></span><br></pre></td></tr></table></figure>
<h2 id="堆区-Heap"><a href="#堆区-Heap" class="headerlink" title="堆区(Heap)"></a>堆区(Heap)</h2><ul>
<li>堆区的内存分配使用的是alloc，代码中创建的对象一般都存在堆中</li>
<li>需要程序猿管理内存；</li>
<li>ARC的内存的管理，是编译器再便宜的时候自动添加 retain、release、autorelease；</li>
<li>堆区的地址是从低到高分配）</li>
</ul>
<h2 id="栈区-Stack"><a href="#栈区-Stack" class="headerlink" title="栈区(Stack)"></a>栈区(Stack)</h2><ul>
<li>存放的局部变量、先进后出、一旦出了作用域就会被销毁；函数跳转地址，现场保护等；</li>
<li>程序猿不需要管理栈区变量的内存；</li>
<li>栈区地址从高到低分配；   </li>
</ul>
<p><img src="/uploads/iOSMemoryLayout/iOSMemoryLayout-image.png" alt=""></p>
<h1 id="具体代码分析"><a href="#具体代码分析" class="headerlink" title="具体代码分析"></a>具体代码分析</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别创建相同的全局变量</span></span><br><span class="line"></span><br><span class="line">NSInteger a = <span class="number">100</span>;</span><br><span class="line">NSString *str1 = @<span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">const</span> NSString *str2 = @<span class="string">"123"</span>;</span><br><span class="line">NSString *strEm1 = @<span class="string">""</span>;</span><br><span class="line">NSString *strEm2 = @<span class="string">""</span>;</span><br><span class="line">NSInteger b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSString *str3 = @<span class="string">"123"</span>;</span><br><span class="line">    NSString *strEm3 = @<span class="string">""</span>;</span><br><span class="line">    NSMutableString *mutStr = [[NSMutableString alloc] init];</span><br><span class="line">    NSString *strEm4 = [NSString <span class="built_in">string</span>];</span><br><span class="line">    NSString *strEm5 = [[NSString alloc] init];</span><br><span class="line">    NSLog(@<span class="string">"str1:  %p---%p---%@"</span>, str1, &amp;str1, str1.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"str2:  %p---%p---%@"</span>, str2, &amp;str2, str2.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"str3:  %p---%p---%@"</span>, str3, &amp;str3, str3.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"strEm1:%p---%p---%@"</span>, strEm1, &amp;strEm1, strEm1.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"strEm2:%p---%p---%@"</span>, strEm2, &amp;strEm2, strEm2.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"strEm3:%p---%p---%@"</span>, strEm3, &amp;strEm3, strEm3.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"strEm4:%p---%p---%@"</span>, strEm4, &amp;strEm4, strEm4.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"strEm5:%p---%p---%@"</span>, strEm5, &amp;strEm5, strEm5.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"mutStr:%p---%p---%@"</span>, mutStr, &amp;mutStr, mutStr.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"a:     %p"</span>, &amp;a);</span><br><span class="line">    NSLog(@<span class="string">"b:     %p"</span>, &amp;b);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">str1:  <span class="number">0x10e117070</span>--<span class="number">-0x10e118048</span>---__NSCFConstantString</span><br><span class="line">str2:  <span class="number">0x10e117070</span>--<span class="number">-0x10e118050</span>---__NSCFConstantString</span><br><span class="line">str3:  <span class="number">0x10e117070</span>--<span class="number">-0x7ffee1ae7fe8</span>---__NSCFConstantString</span><br><span class="line">    </span><br><span class="line">strEm1:<span class="number">0x10e117090</span>--<span class="number">-0x10e118058</span>---__NSCFConstantString</span><br><span class="line">strEm2:<span class="number">0x10e117090</span>--<span class="number">-0x10e118060</span>---__NSCFConstantString</span><br><span class="line">strEm3:<span class="number">0x10e117090</span>--<span class="number">-0x7ffee1ae7fe0</span>---__NSCFConstantString</span><br><span class="line">    </span><br><span class="line">strEm4:<span class="number">0x10e713338</span>--<span class="number">-0x7ffee1ae7fd0</span>---__NSCFConstantString</span><br><span class="line">strEm5:<span class="number">0x10e713338</span>--<span class="number">-0x7ffee1ae7fc8</span>---__NSCFConstantString</span><br><span class="line">mutStr:<span class="number">0x60400025caa0</span>--<span class="number">-0x7ffee1ae7fd8</span>---__NSCFString</span><br><span class="line">a:     <span class="number">0x10e118040</span></span><br><span class="line">b:     <span class="number">0x10e118068</span></span><br></pre></td></tr></table></figure>
<p>由此可以看出：</p>
<ol>
<li><p>直接以<code>@&quot;</code>创建的字符串对象都存储在字符串常量区，而且相同的字符串只会在内存中存在一份。其他用到此字符串的变量/常量指针指向这块内存。</p>
</li>
<li><p>全局变量储存在全局区，如 <code>a</code>，<code>b</code>，<code>str1</code>，<code>str2</code>，<code>strEm1</code>，<code>strEm2</code>，其中<code>str1</code>，<code>str2</code>，<code>strEm1</code>，<code>strEm2</code>是指针，指向的字符串常量对象在常量区。</p>
</li>
<li><p><code>str3</code>，<code>strEm3</code>是局部变量，内存在栈区，指向的字符串常量对象在常量区。</p>
</li>
<li><p><code>strEm4</code>，<code>strEm5</code>也是局部变量，内存在栈区，但是其指向的对象是用类创建的空字符串（类型<code>__NSCFConstantString</code>），是预先创建好的，存储在全局区。</p>
</li>
<li><p><code>mutStr</code>可变字符串指针，内存在栈区；指向的可变字符串对象在堆区。一般创建的对象都存储在堆区，指针变量指向这些对象，局部变量本身的内存在栈区。</p>
</li>
<li><p><code>@&quot;123&quot;</code>本身就是常量，所以 <code>str2</code>之前的 <code>const</code>的写与不写没什么区别。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C语言的内存分布]]></title>
      <url>http://liugangqiang.com/2017/05/09/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</url>
      <content type="html"><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>经典的 C 语言内存分布包括以下 5 个部分:</p>
<ol>
<li>代码段 (Text segment)</li>
<li>初始化数据段 (Initialized data segment)</li>
<li>未初始化数据段 (Uninitialized data segment)</li>
<li>堆区 (Heap)</li>
<li>栈区 (Stack)</li>
</ol>
<a id="more"></a>
<p><img src="/uploads/memoryLayoutC.jpg" alt=""></p>
<p><img src="/uploads/memoryLayoutD.png" alt=""></p>
<p>这是 C 语言程序运行中的经典内存布局，从低地址区域到高以此排布是：代码段、初始化数据段、未初始化数据段、堆、栈。</p>
<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>代码段 (Text segment)，又叫做文本段。存放 CPU 执行的机器指令 (machine instructions)。</p>
<ul>
<li>通常，代码区是可以共享的（另外的执行程序可以调用它），因为对于频繁操作被执行的的程序，只需要在内存中有一份代码即可。</li>
<li>代码区通常是只读的，防止程序意外的修改了它的指令。</li>
<li>代码区在低地址区域，以防止堆或者栈的溢出</li>
</ul>
<h2 id="初始化数据段"><a href="#初始化数据段" class="headerlink" title="初始化数据段"></a>初始化数据段</h2><p>初始化数据段 (Initialized data segment) 是程序的虚拟地址空间的一部分，它包含由程序员初始化的全局变量和静态变量。</p>
<ul>
<li>数据区不是只读的，因为变量的值可以在运行时改变</li>
<li>该区可进一步分为初始化只读区和初始化读写区</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个在任何函数外的全局变量，存储在初始化读写区域中</span></span><br><span class="line"><span class="keyword">int</span> maxCount = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个静态数据</span></span><br><span class="line"><span class="comment">// 字符文本 “hello world” 存储在初始化只读区域中</span></span><br><span class="line"><span class="comment">// 指针变量 string 存储在在初始化读写区域中</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span> = “hello world”;</span><br></pre></td></tr></table></figure>
<h2 id="未初始化数据段"><a href="#未初始化数据段" class="headerlink" title="未初始化数据段"></a>未初始化数据段</h2><p>未初始化数据段 (Uninitialized data segment)，亦称BSS区，BSS这个叫法是根据一个早期的汇编运算符而来，这个汇编运算符标志着一个块的开始。</p>
<ul>
<li>BSS区从初始化数据区的末尾开始，包含所有全局变量和静态变量，这些变量初始化为零或源代码中没有显式初始化</li>
<li>BSS区的数据在程序开始执行之前被内核初始化为 0 或者空指针（NULL）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个变量都会被存储在未初始化数据区</span></span><br><span class="line"><span class="keyword">long</span> sum[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i；</span><br></pre></td></tr></table></figure>
<h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><p>栈区（stack）。由编译器自动分配释放，存放函数的参数值、局部变量的值、函数的返回值等。</p>
<ul>
<li>其操作方式类似于数据结构中的栈。</li>
<li>除了存储局部变量的值外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。</li>
<li>由于栈的先进先出特点，所以栈特别方便用来保存/ 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li>
</ul>
<h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p>堆 (heap) 是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。</p>
<ul>
<li>一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 </li>
<li>当进程调用<code>malloc</code>等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）</li>
<li>当利用<code>free</code>等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</li>
<li>在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并将在内存中为这些段分配空间。栈段亦由操作系统分配和管理，而不需要程序员显示地管理；堆段由程序员自己管理，即显式地申请和释放空间。</li>
</ul>
<h2 id="堆区和栈区的区别"><a href="#堆区和栈区的区别" class="headerlink" title="堆区和栈区的区别"></a>堆区和栈区的区别</h2><h3 id="管理分配方式"><a href="#管理分配方式" class="headerlink" title="管理分配方式"></a>管理分配方式</h3><p>   栈的分配和释放是由编译器完成的，栈的动态分配由<code>alloca()</code>函数完成，无需程序员手工控制；</p>
<p>   堆都是程序中由<code>malloc()</code>函数动态申请分配并由<code>free()</code>函数释放的，申请释放工作由程序员控制，容易产生内存泄漏。</p>
<h3 id="空间大小"><a href="#空间大小" class="headerlink" title="空间大小"></a>空间大小</h3><p>   栈是向低地址扩展的数据结构，是一块连续的内存区域。栈顶的地址和栈的最大容量是系统预先规定好的，当超出申当申请的空间超过栈的剩余空间时，将提示溢出，用户能从栈获得的空间较小。在 WINDOWS 下，栈的大小是2M；</p>
<p>   堆是向高地址扩展的数据结构，是不连续的内存区域。因为系统是用链表来存储空闲内存地址的，且链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间较灵活，也较大。</p>
<h3 id="是否产生碎片"><a href="#是否产生碎片" class="headerlink" title="是否产生碎片"></a>是否产生碎片</h3><p>   对于堆来讲，频繁的malloc/free（new/delete）势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低（虽然程序在退出后操作系统会对内存进行回收管理）；</p>
<p>   对于栈来讲，则不会存在这个问题。</p>
<h3 id="增长方向"><a href="#增长方向" class="headerlink" title="增长方向"></a>增长方向</h3><p>   堆的增长方向是向上的，即向着内存地址增加的方向；</p>
<p>   栈的增长方向是向下的，即向着内存地址减小的方向。</p>
<h3 id="分配效率"><a href="#分配效率" class="headerlink" title="分配效率"></a>分配效率</h3><p>   栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行。系统自动分配，速度较快，程序员是无法控制的；</p>
<p>   堆则是C函数库提供的，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大的空间，如果没有足够大的空间（可能是由于内存碎片太多），就有需要操作系统来重新整理内存空间，这样就有机会分到足够大小的内存，然后返回。由<code>new</code>分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。</p>
<h3 id="申请后系统的响应"><a href="#申请后系统的响应" class="headerlink" title="申请后系统的响应"></a>申请后系统的响应</h3><p>   栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p>   堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的<code>delete</code>语句才能正确的释放本内存空间。由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>
<h3 id="存储的内容"><a href="#存储的内容" class="headerlink" title="存储的内容"></a>存储的内容</h3><p>   堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</p>
<p>   栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量（静态变量不入栈）。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。栈中的内存是在程序编译完成以后就可以确定的，不论占用空间大小，还是每个变量的类型。</p>
<h3 id="防止越界"><a href="#防止越界" class="headerlink" title="防止越界"></a>防止越界</h3><p>   无论是堆还是栈，都要防止越界现象的发生（除非故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生意想不到的结果。debug相当困难。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS分词]]></title>
      <url>http://liugangqiang.com/2016/10/25/iOS%E5%88%86%E8%AF%8D/</url>
      <content type="html"><![CDATA[<p>最近锤子科技发布新手机，手机推出重大功能分词（Big Bang），其实 iOS 拥有分词的 API，代码如下</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (NSArray *)stringTokenizerWithWord:(NSString *)word &#123;</span><br><span class="line">    NSMutableArray *keyWords = [NSMutableArray new];</span><br><span class="line">    CFStringTokenizerRef ref = CFStringTokenizerCreate(NULL, (__bridge CFStringRef)word, CFRangeMake(0, word.length),kCFStringTokenizerUnitWord,NULL);</span><br><span class="line">    CFRange range;</span><br><span class="line">    NSString *keyWord;</span><br><span class="line">    do &#123;</span><br><span class="line">        CFStringTokenizerAdvanceToNextToken(ref);</span><br><span class="line">        range = CFStringTokenizerGetCurrentTokenRange(ref);</span><br><span class="line">        if (range.length == 0) break;</span><br><span class="line">        keyWord = [word substringWithRange:NSMakeRange(range.location, range.length)];</span><br><span class="line">        [keyWords addObject:keyWord];</span><br><span class="line">    &#125; while (range.length &gt; 0); </span><br><span class="line">    return keyWords;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CocoaPods安装和使用]]></title>
      <url>http://liugangqiang.com/2016/07/04/CocoaPods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="CocoaPods-简介"><a href="#CocoaPods-简介" class="headerlink" title="CocoaPods 简介"></a>CocoaPods 简介</h2><p>在 iOS 应用的开发过程中，经常会使用到第三方的开源类库，例如AFNetWorking、SDWebimage 等等。通常，我们会把第三方的框架从网上下载下来， 再拖入到我们的项目中，但是这样一个一个的操作十分繁琐，而且存在<strong>第三方库更新不及时，不易集中管理的问题</strong>。<br><a href="https://cocoapods.org" target="_blank" rel="external">CocoaPods</a> 是为解决此类问题而产生的第三方类库管理工具。它将第三方库集中到一起管理，只需要一行终端命令就第三方库进行安装、更新等处理。绝大部分有名的开源类库，都支持CocoaPods。作为iOS开发程序员，掌握 CocoaPods 的使用时必不可少的基本技能之一。</p>
<a id="more"></a>
<h2 id="CocoaPods-的安装"><a href="#CocoaPods-的安装" class="headerlink" title="CocoaPods 的安装"></a>CocoaPods 的安装</h2><h3 id="安装配置-Ruby-环境"><a href="#安装配置-Ruby-环境" class="headerlink" title="安装配置 Ruby 环境"></a>安装配置 Ruby 环境</h3><h4 id="检查-Ruby-环境（安装）"><a href="#检查-Ruby-环境（安装）" class="headerlink" title="检查 Ruby 环境（安装）"></a>检查 Ruby 环境（安装）</h4><p>CocoaPods 是使用 Ruby 语言编写，所以安装之前需要先安装 Ruby 环境。默认情况下，Mac OS X 系统已经安装好 Ruby。在终端直接使用以下命令，确认系统系统 Ruby 的版本信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ruby --version</span><br><span class="line">或者 </span><br><span class="line">$ ruby --v</span><br><span class="line"></span><br><span class="line">// 输出版本信息大致如下</span><br><span class="line">// ruby 2.0.0p648 (2015-12-16 revision 53162) [universal.x86_64-darwin15]</span><br></pre></td></tr></table></figure></p>
<p>如果没有安装 Ruby，<a href="https://github.com/ruby-china/ruby-china/wiki/Mac-OS-X-上安装-Ruby" target="_blank" rel="external">点击这里进行安装</a></p>
<h4 id="更换-Ruby-源链接"><a href="#更换-Ruby-源链接" class="headerlink" title="更换 Ruby 源链接"></a>更换 Ruby 源链接</h4><p>Ruby 默认的源为 <code>https://rubygems.org</code>，因为这个源在墙外，直接访问这个源使用 CocoaPods 速度会非常慢（很可能安装失败）。<del>但是，我们可以使用淘宝的 Ruby 镜像来访问 CocoaPods</del>（淘宝镜像服务已经停止，由<code>https://gems.ruby-china.org/</code>接管）。</p>
<p>查看 Ruby 源。如果网址为 <del><code>https://ruby.taobao.org/</code></del>（<code>https://gems.ruby-china.org/</code>），则说明之前已经进行过更换，可以直接安装 CocoaPods。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span><br><span class="line">// *** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">// https://rubygems.org/</span><br></pre></td></tr></table></figure></p>
<p>移除 Ruby 源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --remove https://rubygems.org/</span><br><span class="line">// https://rubygems.org/ removed from sources</span><br></pre></td></tr></table></figure></p>
<p>添加新的 Ruby 源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -a https://gems.ruby-china.org/</span><br><span class="line">// https://gems.ruby-china.org/ added to sources</span><br><span class="line"></span><br><span class="line">// $ gem sources -a https://ruby.taobao.org/ 已废弃</span><br></pre></td></tr></table></figure></p>
<p>检查是否添加成功<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span><br></pre></td></tr></table></figure></p>
<p>在终端中显示如下结果时，说明更换成功<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//gems.ruby-china.org/</span></span><br></pre></td></tr></table></figure></p>
<h3 id="安装-CocoaPods"><a href="#安装-CocoaPods" class="headerlink" title="安装 CocoaPods"></a>安装 CocoaPods</h3><p>在终端运行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure></p>
<p>运行之后，需要输入电脑的密码，并且没有密码输入位数的提醒。密码输入正确之后就进行安装了，安装可能需要很长时间，耐心等待。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Fetching: cocoapods-core<span class="number">-1.0</span><span class="number">.1</span>.gem (<span class="number">100</span>%)</span><br><span class="line">Successfully installed cocoapods-core<span class="number">-1.0</span><span class="number">.1</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Parsing documentation <span class="keyword">for</span> cocoapods<span class="number">-1.0</span><span class="number">.1</span></span><br><span class="line">Installing ri documentation <span class="keyword">for</span> cocoapods<span class="number">-1.0</span><span class="number">.1</span></span><br><span class="line"><span class="number">13</span> gems installed</span><br></pre></td></tr></table></figure></p>
<p>出现类似这样的提示，就说明 CocoaPods 安装成功了</p>
<h2 id="CocoaPods-的使用"><a href="#CocoaPods-的使用" class="headerlink" title="CocoaPods 的使用"></a>CocoaPods 的使用</h2><h3 id="创建-Podfile-文件"><a href="#创建-Podfile-文件" class="headerlink" title="创建 Podfile 文件"></a>创建 Podfile 文件</h3><p>在终端定位到需要使用 CocoaPods 的项目的工程目录，使用命令创建一个 Podfile 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /Users/new/Desktop/YourProject</span><br><span class="line">$ pod init</span><br></pre></td></tr></table></figure></p>
<p>出现如下文件<br><img src="/uploads/Cocopods-image1.png" alt=""><br>创建成功</p>
<h3 id="编辑-Podfile-文件"><a href="#编辑-Podfile-文件" class="headerlink" title="编辑 Podfile 文件"></a>编辑 Podfile 文件</h3><p>打开 Podfile 文件<br><img src="/uploads/Cocopods-image2.png" alt=""><br>带<code>#</code>的为注释</p>
<ol>
<li>删除掉第二行的<code>#</code>,为你的项目设置最低支持的 iOS 版本。</li>
<li>在 <code>target &#39;YourProject&#39; do</code> 和 <code>end</code> 之间输入你想导入的框架，如 AFNetworking:<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target 'YourProject' do</span><br><span class="line">  # Uncomment this line if you're using Swift or would like to use dynamic frameworks</span><br><span class="line">  # use_frameworks!</span><br><span class="line">  # Pods for YourProject</span><br><span class="line">pod ‘AFNetworking’</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="执行命令安装-CocoaPods"><a href="#执行命令安装-CocoaPods" class="headerlink" title="执行命令安装 CocoaPods"></a>执行命令安装 CocoaPods</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod install</span><br></pre></td></tr></table></figure>
<p>等待执行完毕，即可完成 CocoaPods 的安装。</p>
<p>另外，也可以使用更新 CocoaPods 版本并进行安装<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod update</span><br></pre></td></tr></table></figure></p>
<p><code>pod install</code> 和 <code>pod update</code>执行过程中都会更新 podpec 的索引，有时速度会很慢，为了提高速度，可以输入如下命令，在不更新索引的情况下执行命令：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod install --no-repo-update</span><br></pre></td></tr></table></figure></p>
<p>也可以在每条命令后加 <code>--verbose</code> 显示详细的命令执行内容</p>
<h3 id="项目打开方式改变"><a href="#项目打开方式改变" class="headerlink" title="项目打开方式改变"></a>项目打开方式改变</h3><p>安装成功后，项目目录下回多出几个文件，以后打开文件要使用箭头所指白色的<code>.xcworkspace</code>文件，不再使用蓝色的<code>.xcodeproj</code>文件。<br><img src="/uploads/Cocopods-image3.png" alt=""><br>项目打开之后，层级结构如下<br><img src="/uploads/Cocopods-image5.png" alt=""><br>上边的是我们原先的项目代码，下边的是 CocoaPods 文件以及它导入的第三方库。</p>
<p>需要注意的是，要引用 CocoaPods 导入的第三方库，要使用 <code>&lt;&gt;</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;AFNetworking.h&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="添加或者删除第三方库"><a href="#添加或者删除第三方库" class="headerlink" title="添加或者删除第三方库"></a>添加或者删除第三方库</h3><p>CocoaPods 安装完成后，再安装或者删除第三方库，只需要编辑 Podfile 文件添加或者删除对应的引用，然后执行<code>pod install</code> 或者 <code>pod update</code>命令即可。<br><img src="/uploads/Cocopods-image4.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://liugangqiang.com/2016/06/17/hello-world/</url>
      <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>Welcome to <em>The Poem and The Distance</em> ! I`m <em>刚刚</em> .</p>
<a id="more"></a>
]]></content>
    </entry>
    
  
  
</search>
