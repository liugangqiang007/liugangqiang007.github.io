<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[C语言的内存分布]]></title>
      <url>http://liugangqiang.com/2018/05/09/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</url>
      <content type="html"><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>经典的 C 语言内存分布包括以下 5 个部分:</p>
<ol>
<li>代码区 (Text segment)</li>
<li>初始化数据区 (Initialized data segment)</li>
<li>未初始化数据区 (Uninitialized data segment)</li>
<li>栈区 (Stack)</li>
<li>堆区 (Heap)</li>
</ol>
<a id="more"></a>
<p><img src="/uploads/memoryLayoutC.jpg" alt=""></p>
<p><img src="/uploads/memoryLayoutD.png" alt=""></p>
<p>这是 C 语言程序运行中的经典内存布局，从低地址区域到高以此排布是：代码区、初始化数据区、未初始化数据区、堆、栈。</p>
<h2 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h2><p>代码区 (Text segment)，又叫做文本区。存放 CPU 执行的机器指令 (machine instructions)。</p>
<ul>
<li>通常，代码区是可以共享的（另外的执行程序可以调用它），因为对于频繁操作被执行的的程序，只需要在内存中有一份代码即可。</li>
<li>代码区通常是只读的，防止程序意外的修改了它的指令。</li>
<li>代码区在低地址区域，以防止堆或者栈的溢出</li>
</ul>
<h2 id="初始化数据区"><a href="#初始化数据区" class="headerlink" title="初始化数据区"></a>初始化数据区</h2><p>初始化数据区 (Initialized data segment) 是程序的虚拟地址空间的一部分，它包含由程序员初始化的全局变量和静态变量。</p>
<ul>
<li>数据区不是只读的，因为变量的值可以在运行时改变</li>
<li>该区可进一步分为初始化只读区和初始化读写区</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个在任何函数外的全局变量，存储在初始化读写区域中</span></span><br><span class="line"><span class="keyword">int</span> maxCount = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个静态数据</span></span><br><span class="line"><span class="comment">// 字符文本 “hello world” 存储在初始化只读区域中</span></span><br><span class="line"><span class="comment">// 指针变量 string 存储在在初始化读写区域中</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span> = “hello world”;</span><br></pre></td></tr></table></figure>
<h2 id="未初始化数据区"><a href="#未初始化数据区" class="headerlink" title="未初始化数据区"></a>未初始化数据区</h2><p>未初始化数据区 (Uninitialized data segment)，亦称BSS区，BSS这个叫法是根据一个早期的汇编运算符而来，这个汇编运算符标志着一个块的开始。</p>
<ul>
<li>BSS区从初始化数据区的末尾开始，包含所有全局变量和静态变量，这些变量初始化为零或源代码中没有显式初始化</li>
<li>BSS区的数据在程序开始执行之前被内核初始化为 0 或者空指针（NULL）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个变量都会被存储在未初始化数据区</span></span><br><span class="line"><span class="keyword">long</span> sum[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i；</span><br></pre></td></tr></table></figure>
<h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><p>栈区（stack）。由编译器自动分配释放，存放函数的参数值、局部变量的值、函数的返回值等。</p>
<ul>
<li>其操作方式类似于数据结构中的栈。</li>
<li>除了存储局部变量的值外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。</li>
<li>由于栈的先进先出特点，所以栈特别方便用来保存/ 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li>
</ul>
<h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p>堆 (heap) 是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。</p>
<ul>
<li>一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 </li>
<li>当进程调用<code>malloc</code>等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）</li>
<li>当利用<code>free</code>等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</li>
<li>在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并将在内存中为这些段分配空间。栈段亦由操作系统分配和管理，而不需要程序员显示地管理；堆段由程序员自己管理，即显式地申请和释放空间。</li>
</ul>
<h2 id="堆区和栈区的区别"><a href="#堆区和栈区的区别" class="headerlink" title="堆区和栈区的区别"></a>堆区和栈区的区别</h2><h3 id="管理分配方式"><a href="#管理分配方式" class="headerlink" title="管理分配方式"></a>管理分配方式</h3><p>   栈的分配和释放是由编译器完成的，栈的动态分配由<code>alloca()</code>函数完成，无需程序员手工控制；</p>
<p>   堆都是程序中由<code>malloc()</code>函数动态申请分配并由<code>free()</code>函数释放的，申请释放工作由程序员控制，容易产生内存泄漏。</p>
<h3 id="空间大小"><a href="#空间大小" class="headerlink" title="空间大小"></a>空间大小</h3><p>   栈是向低地址扩展的数据结构，是一块连续的内存区域。栈顶的地址和栈的最大容量是系统预先规定好的，当超出申当申请的空间超过栈的剩余空间时，将提示溢出，用户能从栈获得的空间较小。在 WINDOWS 下，栈的大小是2M；</p>
<p>   堆是向高地址扩展的数据结构，是不连续的内存区域。因为系统是用链表来存储空闲内存地址的，且链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间较灵活，也较大。</p>
<h3 id="是否产生碎片"><a href="#是否产生碎片" class="headerlink" title="是否产生碎片"></a>是否产生碎片</h3><p>   对于堆来讲，频繁的malloc/free（new/delete）势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低（虽然程序在退出后操作系统会对内存进行回收管理）；</p>
<p>   对于栈来讲，则不会存在这个问题。</p>
<h3 id="增长方向"><a href="#增长方向" class="headerlink" title="增长方向"></a>增长方向</h3><p>   堆的增长方向是向上的，即向着内存地址增加的方向；</p>
<p>   栈的增长方向是向下的，即向着内存地址减小的方向。</p>
<h3 id="分配效率"><a href="#分配效率" class="headerlink" title="分配效率"></a>分配效率</h3><p>   栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行。系统自动分配，速度较快，程序员是无法控制的；</p>
<p>   堆则是C函数库提供的，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大的空间，如果没有足够大的空间（可能是由于内存碎片太多），就有需要操作系统来重新整理内存空间，这样就有机会分到足够大小的内存，然后返回。由<code>new</code>分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。</p>
<h3 id="申请后系统的响应"><a href="#申请后系统的响应" class="headerlink" title="申请后系统的响应"></a>申请后系统的响应</h3><p>   栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p>   堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的<code>delete</code>语句才能正确的释放本内存空间。由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>
<h3 id="存储的内容"><a href="#存储的内容" class="headerlink" title="存储的内容"></a>存储的内容</h3><p>   堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</p>
<p>   栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量（静态变量不入栈）。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。栈中的内存是在程序编译完成以后就可以确定的，不论占用空间大小，还是每个变量的类型。</p>
<h3 id="防止越界"><a href="#防止越界" class="headerlink" title="防止越界"></a>防止越界</h3><p>   无论是堆还是栈，都要防止越界现象的发生（除非故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生意想不到的结果。debug相当困难。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS分词]]></title>
      <url>http://liugangqiang.com/2016/10/25/iOS%E5%88%86%E8%AF%8D/</url>
      <content type="html"><![CDATA[<p>最近锤子科技发布新手机，手机推出重大功能分词（Big Bang），其实 iOS 拥有分词的 API，代码如下</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (NSArray *)stringTokenizerWithWord:(NSString *)word &#123;</span><br><span class="line">    NSMutableArray *keyWords = [NSMutableArray <span class="keyword">new</span>];</span><br><span class="line">    CFStringTokenizerRef ref = CFStringTokenizerCreate(<span class="literal">NULL</span>, (__bridge CFStringRef)word, CFRangeMake(<span class="number">0</span>, word.length),kCFStringTokenizerUnitWord,<span class="literal">NULL</span>);</span><br><span class="line">    CFRange range;</span><br><span class="line">    NSString *keyWord;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        CFStringTokenizerAdvanceToNextToken(ref);</span><br><span class="line">        range = CFStringTokenizerGetCurrentTokenRange(ref);</span><br><span class="line">        <span class="keyword">if</span> (range.length == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        keyWord = [word substringWithRange:NSMakeRange(range.location, range.length)];</span><br><span class="line">        [keyWords addObject:keyWord];</span><br><span class="line">    &#125; <span class="keyword">while</span> (range.length &gt; <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> keyWords;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CocoaPods安装和使用]]></title>
      <url>http://liugangqiang.com/2016/07/04/CocoaPods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="CocoaPods-简介"><a href="#CocoaPods-简介" class="headerlink" title="CocoaPods 简介"></a>CocoaPods 简介</h2><p>在 iOS 应用的开发过程中，经常会使用到第三方的开源类库，例如AFNetWorking、SDWebimage 等等。通常，我们会把第三方的框架从网上下载下来， 再拖入到我们的项目中，但是这样一个一个的操作十分繁琐，而且存在<strong>第三方库更新不及时，不易集中管理的问题</strong>。<br><a href="https://cocoapods.org" target="_blank" rel="external">CocoaPods</a> 是为解决此类问题而产生的第三方类库管理工具。它将第三方库集中到一起管理，只需要一行终端命令就第三方库进行安装、更新等处理。绝大部分有名的开源类库，都支持CocoaPods。作为iOS开发程序员，掌握 CocoaPods 的使用时必不可少的基本技能之一。</p>
<a id="more"></a>
<h2 id="CocoaPods-的安装"><a href="#CocoaPods-的安装" class="headerlink" title="CocoaPods 的安装"></a>CocoaPods 的安装</h2><h3 id="安装配置-Ruby-环境"><a href="#安装配置-Ruby-环境" class="headerlink" title="安装配置 Ruby 环境"></a>安装配置 Ruby 环境</h3><h4 id="检查-Ruby-环境（安装）"><a href="#检查-Ruby-环境（安装）" class="headerlink" title="检查 Ruby 环境（安装）"></a>检查 Ruby 环境（安装）</h4><p>CocoaPods 是使用 Ruby 语言编写，所以安装之前需要先安装 Ruby 环境。默认情况下，Mac OS X 系统已经安装好 Ruby。在终端直接使用以下命令，确认系统系统 Ruby 的版本信息：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ruby --version</span><br><span class="line">或者 </span><br><span class="line">$ ruby --v</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出版本信息大致如下</span></span><br><span class="line"><span class="comment">// ruby 2.0.0p648 (2015-12-16 revision 53162) [universal.x86_64-darwin15]</span></span><br></pre></td></tr></table></figure></p>
<p>如果没有安装 Ruby，<a href="https://github.com/ruby-china/ruby-china/wiki/Mac-OS-X-上安装-Ruby" target="_blank" rel="external">点击这里进行安装</a></p>
<h4 id="更换-Ruby-源链接"><a href="#更换-Ruby-源链接" class="headerlink" title="更换 Ruby 源链接"></a>更换 Ruby 源链接</h4><p>Ruby 默认的源为 <code>https://rubygems.org</code>，因为这个源在墙外，直接访问这个源使用 CocoaPods 速度会非常慢（很可能安装失败）。<del>但是，我们可以使用淘宝的 Ruby 镜像来访问 CocoaPods</del>（淘宝镜像服务已经停止，由<code>https://gems.ruby-china.org/</code>接管）。</p>
<p>查看 Ruby 源。如果网址为 <del><code>https://ruby.taobao.org/</code></del>（<code>https://gems.ruby-china.org/</code>），则说明之前已经进行过更换，可以直接安装 CocoaPods。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span><br><span class="line"><span class="comment">// *** CURRENT SOURCES ***</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://rubygems.org/</span></span><br></pre></td></tr></table></figure></p>
<p>移除 Ruby 源<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --remove https:<span class="comment">//rubygems.org/</span></span><br><span class="line"><span class="comment">// https://rubygems.org/ removed from sources</span></span><br></pre></td></tr></table></figure></p>
<p>添加新的 Ruby 源<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -a https:<span class="comment">//gems.ruby-china.org/</span></span><br><span class="line"><span class="comment">// https://gems.ruby-china.org/ added to sources</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $ gem sources -a https://ruby.taobao.org/ 已废弃</span></span><br></pre></td></tr></table></figure></p>
<p>检查是否添加成功<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span><br></pre></td></tr></table></figure></p>
<p>在终端中显示如下结果时，说明更换成功<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//gems.ruby-china.org/</span></span><br></pre></td></tr></table></figure></p>
<h3 id="安装-CocoaPods"><a href="#安装-CocoaPods" class="headerlink" title="安装 CocoaPods"></a>安装 CocoaPods</h3><p>在终端运行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure></p>
<p>运行之后，需要输入电脑的密码，并且没有密码输入位数的提醒。密码输入正确之后就进行安装了，安装可能需要很长时间，耐心等待。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Fetching: cocoapods-core<span class="number">-1.0</span><span class="number">.1</span>.gem (<span class="number">100</span>%)</span><br><span class="line">Successfully installed cocoapods-core<span class="number">-1.0</span><span class="number">.1</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Parsing documentation <span class="keyword">for</span> cocoapods<span class="number">-1.0</span><span class="number">.1</span></span><br><span class="line">Installing ri documentation <span class="keyword">for</span> cocoapods<span class="number">-1.0</span><span class="number">.1</span></span><br><span class="line"><span class="number">13</span> gems installed</span><br></pre></td></tr></table></figure></p>
<p>出现类似这样的提示，就说明 CocoaPods 安装成功了</p>
<h2 id="CocoaPods-的使用"><a href="#CocoaPods-的使用" class="headerlink" title="CocoaPods 的使用"></a>CocoaPods 的使用</h2><h3 id="创建-Podfile-文件"><a href="#创建-Podfile-文件" class="headerlink" title="创建 Podfile 文件"></a>创建 Podfile 文件</h3><p>在终端定位到需要使用 CocoaPods 的项目的工程目录，使用命令创建一个 Podfile 文件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /Users/<span class="keyword">new</span>/Desktop/YourProject</span><br><span class="line">$ pod init</span><br></pre></td></tr></table></figure></p>
<p>出现如下文件<br><img src="/uploads/Cocopods-image1.png" alt=""><br>创建成功</p>
<h3 id="编辑-Podfile-文件"><a href="#编辑-Podfile-文件" class="headerlink" title="编辑 Podfile 文件"></a>编辑 Podfile 文件</h3><p>打开 Podfile 文件<br><img src="/uploads/Cocopods-image2.png" alt=""><br>带<code>#</code>的为注释</p>
<ol>
<li>删除掉第二行的<code>#</code>,为你的项目设置最低支持的 iOS 版本。</li>
<li>在 <code>target &#39;YourProject&#39; do</code> 和 <code>end</code> 之间输入你想导入的框架，如 AFNetworking:<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target 'YourProject' do</span><br><span class="line">  # Uncomment this line if you're using Swift or would like to use dynamic frameworks</span><br><span class="line">  # use_frameworks!</span><br><span class="line">  # Pods for YourProject</span><br><span class="line">pod ‘AFNetworking’</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="执行命令安装-CocoaPods"><a href="#执行命令安装-CocoaPods" class="headerlink" title="执行命令安装 CocoaPods"></a>执行命令安装 CocoaPods</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod install</span><br></pre></td></tr></table></figure>
<p>等待执行完毕，即可完成 CocoaPods 的安装。</p>
<p>另外，也可以使用更新 CocoaPods 版本并进行安装<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod update</span><br></pre></td></tr></table></figure></p>
<p><code>pod install</code> 和 <code>pod update</code>执行过程中都会更新 podpec 的索引，有时速度会很慢，为了提高速度，可以输入如下命令，在不更新索引的情况下执行命令：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod install --no-repo-update</span><br></pre></td></tr></table></figure></p>
<p>也可以在每条命令后加 <code>--verbose</code> 显示详细的命令执行内容</p>
<h3 id="项目打开方式改变"><a href="#项目打开方式改变" class="headerlink" title="项目打开方式改变"></a>项目打开方式改变</h3><p>安装成功后，项目目录下回多出几个文件，以后打开文件要使用箭头所指白色的<code>.xcworkspace</code>文件，不再使用蓝色的<code>.xcodeproj</code>文件。<br><img src="/uploads/Cocopods-image3.png" alt=""><br>项目打开之后，层级结构如下<br><img src="/uploads/Cocopods-image5.png" alt=""><br>上边的是我们原先的项目代码，下边的是 CocoaPods 文件以及它导入的第三方库。</p>
<p>需要注意的是，要引用 CocoaPods 导入的第三方库，要使用 <code>&lt;&gt;</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;AFNetworking.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="添加或者删除第三方库"><a href="#添加或者删除第三方库" class="headerlink" title="添加或者删除第三方库"></a>添加或者删除第三方库</h3><p>CocoaPods 安装完成后，再安装或者删除第三方库，只需要编辑 Podfile 文件添加或者删除对应的引用，然后执行<code>pod install</code> 或者 <code>pod update</code>命令即可。<br><img src="/uploads/Cocopods-image4.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://liugangqiang.com/2016/06/17/hello-world/</url>
      <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>Welcome to <em>The Poem and The Distance</em> ! I`m <em>刚刚</em> .</p>
<a id="more"></a>
]]></content>
    </entry>
    
  
  
</search>
