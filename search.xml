<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Lottie原理分析(一)]]></title>
      <url>http://liugangqiang.com/2018/04/20/Lottie%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="LOTAnimationView"><a href="#LOTAnimationView" class="headerlink" title="LOTAnimationView"></a>LOTAnimationView</h2><p>继承自 <code>LOTView</code> ，其本质上还是 <code>UIView</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键字 @compatibility_alias 的意思是给一个类设置一个别名。这样就可以不用重构以前的类，直接使用新的名字替代原有的名字</span></span><br><span class="line">@compatibility_alias LOTView UIView;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><code>LOTAnimationView</code> 内含有数个构造类方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Load animation by name from the default bundle, Images are also loaded from the bundle</span></span><br><span class="line">+ (instancetype)animationNamed:(NSString *)animationName;</span><br><span class="line">+ (instancetype)animationNamed:(NSString *)animationName inBundle:(NSBundle *)bundle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Creates an animation from the deserialized JSON Dictionary</span></span><br><span class="line">+ (instancetype)animationFromJSON:(NSDictionary *)animationJSON;</span><br><span class="line">+ (instancetype)animationFromJSON:(NSDictionary *)animationJSON inBundle:(NSBundle *)bundle;</span><br><span class="line"><span class="comment">/// 源代码第二个方法 animationJSON 参数使用的 nullable 修饰，应该可以使用 nonnull。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Loads an animation from a specific file path. WARNING Do not use a web URL for file path.</span></span><br><span class="line">+ (instancetype)animationWithFilePath:(NSString *)filePath;</span><br></pre></td></tr></table></figure>
<p>这些方法最终调用 <code>LOTComposition</code> 类的对应方法，然后根据返回的 <code>LOTComposition</code> 对象初始化自己</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)animationNamed:(NSString *)animationName inBundle:(NSBundle *)bundle &#123;</span><br><span class="line">  LOTComposition *comp = [LOTComposition animationNamed:animationName inBundle:bundle];</span><br><span class="line">  <span class="keyword">return</span> [[self alloc] initWithModel:comp inBundle:bundle];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LOTAnimationView 在使用 <code>-initWithModel:inBundle:</code> 初始化时做了四件事</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值 bundle</span></span><br><span class="line">_bundle = bundle;</span><br><span class="line"><span class="comment">// 公共初始化，进行一些参数配置，比如动画速度、进度、是否循环、是否自动意逆画等</span></span><br><span class="line">[self _commonInit];</span><br><span class="line"><span class="comment">// 初始化动画容器，内部只有一个操作 self.clipsToBounds = YES</span></span><br><span class="line">[self _initializeAnimationContainer];</span><br><span class="line"><span class="comment">// 设置场景模型，如果 view 原先已有 model，则会先清空之前的操作，再设置</span></span><br><span class="line">[self _setupWithSceneModel:model];</span><br></pre></td></tr></table></figure>
<p> <code>_setupWithSceneModel:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_setupWithSceneModel:(LOTComposition *)model &#123;</span><br><span class="line">  <span class="keyword">if</span> (_sceneModel) &#123;</span><br><span class="line">    <span class="comment">//  如果 view 原先已有 model，先清空之前的操作</span></span><br><span class="line">    [self _removeCurrentAnimationIfNecessary];</span><br><span class="line">    [self _callCompletionIfNecessary:NO];</span><br><span class="line">    [_compContainer removeFromSuperlayer];</span><br><span class="line">    _compContainer = nil;</span><br><span class="line">    _sceneModel = nil;</span><br><span class="line">    [self _commonInit];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  _sceneModel = model;</span><br><span class="line">    <span class="comment">// 初始化 LOTCompositionContainer 对象</span></span><br><span class="line">  _compContainer = [[LOTCompositionContainer alloc] initWithModel:nil inLayerGroup:nil withLayerGroup:_sceneModel.layerGroup withAssestGroup:_sceneModel.assetGroup];</span><br><span class="line">  [self.layer addSublayer:_compContainer];</span><br><span class="line">  [self _restoreState];</span><br><span class="line">  [self setNeedsLayout];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LOTComposition"><a href="#LOTComposition" class="headerlink" title="LOTComposition"></a>LOTComposition</h2><p>继承自 <code>NSObject</code>，负责 json 数据的解析。即将 json 串解析成 OC 对象，包含 json  的解析的所有模型对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法内部会先调用单例对象 LOTAnimationCache ，使用 animationName 去掉后.缀后作为 key, 获取已缓存的 LOTComposition 对象，如果获取到没有，才调用构造方法创建。创建完成后，也会加到缓存池中，并赋值 cacheKey 属性。直接使用 init... 方法或 +animationFromJSON: 方法则不会加入到缓存(因为不知道动画的名字)</span></span><br><span class="line">+(instancetype)animationNamed:(NSString *)animationName inBundle:(NSBundle *)bundle </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 json 文件转 NSDictionary 字典对象</span></span><br><span class="line">NSData *jsonData = [[NSData alloc] initWithContentsOfFile:filePath];</span><br><span class="line">NSDictionary *JSONObject = jsonData ? [NSJSONSerialization JSONObjectWithData:jsonData options:<span class="number">0</span> error:&amp;error] : nil;</span><br></pre></td></tr></table></figure>
<p><code>LOTComposition</code> 类中最重要的内部方法为 <code>-_mapFromJSON:withAssetBundle:</code>，用来解析 json 转化的 字典对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_mapFromJSON:(NSDictionary *)jsonDictionary withAssetBundle:(NSBundle *)bundle </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 获取宽高，确定动画 bounds</span></span><br><span class="line">  NSNumber *width = jsonDictionary[@<span class="string">"w"</span>];</span><br><span class="line">  NSNumber *height = jsonDictionary[@<span class="string">"h"</span>];</span><br><span class="line">  <span class="keyword">if</span> (width &amp;&amp; height) &#123;</span><br><span class="line">    CGRect bounds = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, width.floatValue, height.floatValue);</span><br><span class="line">    _compBounds = bounds;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取动画起始帧，结束帧，和帧速率</span></span><br><span class="line">  _startFrame = [jsonDictionary[@<span class="string">"ip"</span>] copy];</span><br><span class="line">  _endFrame = [jsonDictionary[@<span class="string">"op"</span>] copy];</span><br><span class="line">  _framerate = [jsonDictionary[@<span class="string">"fr"</span>] copy];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据动画帧参数算出动画时间</span></span><br><span class="line">  <span class="keyword">if</span> (_startFrame &amp;&amp; _endFrame &amp;&amp; _framerate) &#123;</span><br><span class="line">    NSInteger frameDuration = (_endFrame.integerValue - _startFrame.integerValue) - <span class="number">1</span>;</span><br><span class="line">    NSTimeInterval timeDuration = frameDuration / _framerate.floatValue;</span><br><span class="line">    _timeDuration = timeDuration;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取资源信息，只是建立对应的 _assetJSONMap</span></span><br><span class="line">  NSArray *assetArray = jsonDictionary[@<span class="string">"assets"</span>];</span><br><span class="line">  <span class="keyword">if</span> (assetArray.count) &#123;</span><br><span class="line">    _assetGroup = [[LOTAssetGroup alloc] initWithJSON:assetArray withAssetBundle:bundle withFramerate:_framerate];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取图层信息，需要资源信息 _assetGroup</span></span><br><span class="line">  NSArray *layersJSON = jsonDictionary[@<span class="string">"layers"</span>];</span><br><span class="line">  <span class="keyword">if</span> (layersJSON) &#123;</span><br><span class="line">    _layerGroup = [[LOTLayerGroup alloc] initWithLayerJSON:layersJSON</span><br><span class="line">                                            withAssetGroup:_assetGroup</span><br><span class="line">                                             withFramerate:_framerate];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据 _framerate 获取资源文件建立 _assetMap，之后置空 _assetJSONMap</span></span><br><span class="line">  [_assetGroup finalizeInitializationWithFramerate:_framerate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法中又包含两个对象 <code>LOTAssetGroup</code>、<code>LOTLayerGroup</code>分别用于存放<code>LOTAsset</code>和<code>LOTLayer</code> 对象。二者都是通过 <code>id ：对象</code>的方式将子对象存储到字典中，方便之后取用。（<code>LOTAsset</code>为<code>id</code>字段，<code>LOTLayer</code> 为<code>ind</code>）。内部还包含其他很多 model，总之，就是对应要解析的 json 字符串需要的各种模型。</p>
<p>###LOTAsset</p>
<p>含有资源的 id、名字、宽、高、文件子路径、包含的子图层等信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSString *referenceID; 	<span class="comment">// 资源id ---id</span></span><br><span class="line">NSNumber *assetWidth;	<span class="comment">// 宽度	---w</span></span><br><span class="line">NSNumber *assetHeight;  <span class="comment">// 高度	---h</span></span><br><span class="line"></span><br><span class="line">NSString *imageName;	<span class="comment">// 图片名字---p</span></span><br><span class="line">NSString *imageDirectory;  <span class="comment">// 文件夹路径	---u</span></span><br><span class="line"></span><br><span class="line">LOTLayerGroup *layerGroup; <span class="comment">// 子图层数组	---layers</span></span><br></pre></td></tr></table></figure>
<h3 id="LOTLayer"><a href="#LOTLayer" class="headerlink" title="LOTLayer"></a>LOTLayer</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">NSString *layerName;	<span class="comment">// 图层名字 ---nm</span></span><br><span class="line">NSString *referenceID;	<span class="comment">// 引用id ---refid</span></span><br><span class="line">NSNumber *layerID;		<span class="comment">// 图层id ---ind</span></span><br><span class="line">LOTLayerType layerType; <span class="comment">// 图层类型,有Precomp、Solid、Image、Null、Shape、Unknown 五种枚举 ---ty</span></span><br><span class="line">NSNumber *parentID;		<span class="comment">// 起源   ---parent</span></span><br><span class="line">NSNumber *startFrame;	<span class="comment">// 开始帧 ---st</span></span><br><span class="line">NSNumber *inFrame;		<span class="comment">// 		 ---ip</span></span><br><span class="line">NSNumber *outFrame;		<span class="comment">// 		 ---op</span></span><br><span class="line">NSNumber *timeStretch;  <span class="comment">// 时间拉伸	---sr</span></span><br><span class="line">CGRect layerBounds;		<span class="comment">// bounds 宽高算出</span></span><br><span class="line"></span><br><span class="line">NSArray&lt;LOTShapeGroup *&gt; *shapes;	<span class="comment">// ---shapes</span></span><br><span class="line">NSArray&lt;LOTMask *&gt; *masks;			<span class="comment">// ---masksProperties</span></span><br><span class="line"></span><br><span class="line">NSNumber *layerWidth;	<span class="comment">// 图层宽	根据不同的layerType值，有不同的获取方式</span></span><br><span class="line">NSNumber *layerHeight;	<span class="comment">// 图层高	</span></span><br><span class="line">UIColor *solidColor;</span><br><span class="line">LOTAsset *imageAsset;</span><br><span class="line"></span><br><span class="line">LOTKeyframeGroup *opacity;		 <span class="comment">// 不透明度   --&gt;ks--&gt;o</span></span><br><span class="line">LOTKeyframeGroup *timeRemapping; <span class="comment">// 时间重映射 ---tm</span></span><br><span class="line">LOTKeyframeGroup *rotation;		 <span class="comment">// 旋转     --&gt;ks--&gt;r或者rz</span></span><br><span class="line">LOTKeyframeGroup *position;		 <span class="comment">// 位置     --&gt;ks--&gt;p</span></span><br><span class="line"></span><br><span class="line">LOTKeyframeGroup *positionX;</span><br><span class="line">LOTKeyframeGroup *positionY;</span><br><span class="line"></span><br><span class="line">LOTKeyframeGroup *anchor;		<span class="comment">// 角度     --&gt;ks--&gt;a</span></span><br><span class="line">LOTKeyframeGroup *scale;		<span class="comment">// 比例     --&gt;ks--&gt;s</span></span><br><span class="line"></span><br><span class="line">LOTMatteType matteType;			<span class="comment">// 磨砂类型  ---tt</span></span><br></pre></td></tr></table></figure>
<h2 id="LOTCompositionContainer"><a href="#LOTCompositionContainer" class="headerlink" title="LOTCompositionContainer"></a>LOTCompositionContainer</h2><p>顾名思义，<code>LOTCompositionContainer</code>是数据 <code>LOTComposition</code> 展示的控件，继承自 <code>LOTLayerContainer</code> ，进而继承自<code>CALayer</code> 。动画效果全部在这里实现。</p>
<h2 id="LOTAnimationCache"><a href="#LOTAnimationCache" class="headerlink" title="LOTAnimationCache"></a>LOTAnimationCache</h2><p>继承自 <code>NSObject</code>，单例对象，用于缓存加载过得 <code>LOTComposition</code> 对象。</p>
<p>内有两个对象<code>animationsCache_</code> 和<code>lruOrderArray_</code> ，分别存储缓存的<code>LOTComposition</code> 对象和 有先后顺序的key</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *animationsCache_;</span><br><span class="line">NSMutableArray *lruOrderArray_;</span><br></pre></td></tr></table></figure>
<p>提供的方法有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Global Cache 获取全局单例对象</span></span><br><span class="line">+ (instancetype)sharedCache;</span><br><span class="line"><span class="comment">/// Adds animation to the cache 添加缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)addAnimation:(LOTComposition *)animation forKey:(NSString *)key;</span><br><span class="line"><span class="comment">/// Returns animation from cache. 获取缓存的对象</span></span><br><span class="line">- (LOTComposition * _Nullable)animationForKey:(NSString *)key;</span><br><span class="line"><span class="comment">/// Removes a specific animation from the cache 移除一个缓存的对象</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAnimationForKey:(NSString *)key;</span><br><span class="line"><span class="comment">/// Clears Everything from the Cache 清除所有缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)clearCache;</span><br><span class="line"><span class="comment">/// Disables Caching Animation Model Objects 不使用缓存池</span></span><br><span class="line">- (<span class="keyword">void</span>)disableCaching;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其内部还有缓存数量限制，最大为50个，超出上限自动清理。可以学习缓存池的规范写法。</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScriptCore 解析]]></title>
      <url>http://liugangqiang.com/2018/04/03/JavaScriptCore%20%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>JavaScript 越来越多的出现在客户端的开发当中，ReactNative、JSPatch 都是利用 JavaScript 与客户端语言结合实现的。在 iOS 中，使 iOS 拥有执行 JavaScript 代码能力的的便是 JavaScriptCore 框架。</p>
<a id="more"></a>
<h2 id="JavaScriptCore-简介"><a href="#JavaScriptCore-简介" class="headerlink" title="JavaScriptCore 简介"></a>JavaScriptCore 简介</h2><p>JavaScriptCore 是苹果 Safari 浏览器的 JavaScript 引擎，是专门处理 JavaScript 脚本的虚拟机。当前主要的还在开发中的 JavaScript 引擎如下</p>
<p><img src="/uploads/JavaScriptCore 解析/1492484148441_6773_1492484148694.png" alt="img"></p>
<p>JavaScriptCore框架 是苹果在 iOS7 引入的框架，使用该框架可以在 Objective-C 或者基于C的程序中执行 Javascript 代码，也可以向 JavaScript 环境中插入一些自定义的对象。</p>
<p>JavaScriptCore框架 其实就是基于 webkit 中以C/C++实现的 JavaScriptCore 的一个包装，在旧版本iOS开发中，很多开发者也会自行将 webkit 的库引入项目编译使用。现在iOS7把它当成了标准库。</p>
<h2 id="JavaScriptCore-解析"><a href="#JavaScriptCore-解析" class="headerlink" title="JavaScriptCore 解析"></a>JavaScriptCore 解析</h2><p>查看 JavaScriptCore.h，可以看到 JavaScriptCore 的几个主要类或协议</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> JavaScriptCore_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JavaScriptCore_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;JavaScriptCore/JavaScript.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;JavaScriptCore/JSStringRefCF.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__OBJC__) &amp;&amp; JSC_OBJC_API_ENABLED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">"JSContext.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="string">"JSValue.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="string">"JSManagedValue.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="string">"JSVirtualMachine.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="string">"JSExport.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* JavaScriptCore_h */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>JSContext</li>
<li>JSValue</li>
<li>JSManagedValue</li>
<li>JSVirtualMachine</li>
<li>JSExport</li>
</ul>
<h3 id="JSVirtualMachine"><a href="#JSVirtualMachine" class="headerlink" title="JSVirtualMachine"></a>JSVirtualMachine</h3><p>一个 <code>JSVirtualMachine</code> 的实例就是一个完整独立的 JavaScript 的执行环境，为 JavaScript 的执行提供底层资源，它有自己独立的堆栈以及垃圾回收机制</p>
<p>这个类主要做两件事情：</p>
<ol>
<li>实现并发的 JavaScript 执行</li>
<li>JavaScript 和 Objective-C 桥接对象的内存管理</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NS_CLASS_AVAILABLE(<span class="number">10</span>_9, <span class="number">7</span>_0)</span><br><span class="line">@interface JSVirtualMachine : NSObject</span><br><span class="line"><span class="comment">/* 创建一个新的完全独立的虚拟机 */</span></span><br><span class="line">- (instancetype)init;</span><br><span class="line"><span class="comment">/* 对桥接对象进行内存管理 */</span></span><br><span class="line">- (<span class="keyword">void</span>)addManagedReference:(id)object withOwner:(id)owner;</span><br><span class="line"><span class="comment">/* 取消对桥接对象进行内存管理 */</span></span><br><span class="line">- (<span class="keyword">void</span>)removeManagedReference:(id)object withOwner:(id)owner;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>每一个JavaScript上下文（JSContext对象）都归属一个虚拟机（JSVirtualMachine对象）。每个虚拟机可以包含多个不同的上下文，并允许在这些不同的上下文之间传值（JSValue对象）。</p>
<p>每个虚拟机都是独立的，有其自己的堆栈以及垃圾回收机制（garbage collector）。GC无法处理别的虚拟机堆中的对象，因此你不能把一个虚拟机中创建的值传给另一个虚拟机。</p>
<p><img src="/uploads/JavaScriptCore 解析/1492484381477_5402_1492484381647.png" alt="img"></p>
<p>JavaScriptCore API 都是线程安全的，是通过锁定虚拟机实现的。你可以在任意线程创建JSValue或者执行JS代码，然而，所有其他想要使用该虚拟机的线程都要等待。</p>
<ul>
<li>如果想并发执行JS，需要使用多个不同的虚拟机来实现。</li>
<li>可以在子线程中执行JS代码。</li>
</ul>
<h3 id="JSContext"><a href="#JSContext" class="headerlink" title="JSContext"></a>JSContext</h3><p>一个 JSContext 对象代表一个JavaScript 执行环境。在native代码中，使用 JSContext 去执行JS代码，访问JS中定义或者计算的值，并使 JavaScript 可以访问native的对象、方法、函数。</p>
<p><img src="/uploads/JavaScriptCore 解析/1492484475516_5068_1492484475859.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">NS_CLASS_AVAILABLE(<span class="number">10</span>_9, <span class="number">7</span>_0)</span><br><span class="line">@interface JSContext : NSObject</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span><br><span class="line">@methodgroup Creating New JSContexts</span><br><span class="line">*/</span></span><br><span class="line"><span class="comment">/* 创建一个JSContext，同时会创建一个新的JSVirtualMachine */</span></span><br><span class="line">- (instancetype)init;</span><br><span class="line"><span class="comment">/* 在指定虚拟机上创建一个JSContext */</span></span><br><span class="line">- (instancetype)initWithVirtualMachine:(JSVirtualMachine *)virtualMachine;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span><br><span class="line">@methodgroup Evaluating Scripts</span><br><span class="line">*/</span></span><br><span class="line"><span class="comment">/* 执行一段JS代码，返回最后生成的一个值 */</span></span><br><span class="line">- (JSValue *)evaluateScript:(NSString *)script;</span><br><span class="line"><span class="comment">/* 执行一段JS代码，并将sourceURL认作其源码URL（仅作标记用） */</span></span><br><span class="line">- (JSValue *)evaluateScript:(NSString *)script withSourceURL:(NSURL *)<span class="function">sourceURL <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span><br><span class="line">@methodgroup Callback Accessors</span><br><span class="line">*/</span></span><br><span class="line"><span class="comment">/* 获取当前执行的JavaScript代码的context */</span></span><br><span class="line">+ (JSContext *)currentContext;</span><br><span class="line"><span class="comment">/* 获取当前执行的JavaScript function*/</span></span><br><span class="line">+ (JSValue *)<span class="function">currentCallee <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>;</span><br><span class="line"><span class="comment">/* 获取当前执行的JavaScript代码的 &lt;code&gt;this&lt;/code&gt; */</span></span><br><span class="line">+ (JSValue *)currentThis;</span><br><span class="line"><span class="comment">/* 获取当前执行的JavaScript代码回调的参数 */</span></span><br><span class="line">+ (NSArray *)currentArguments;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span><br><span class="line">@functiongroup Global Properties</span><br><span class="line">*/</span></span><br><span class="line"><span class="comment">/* 获取当前context的全局对象。WebKit中的context返回的便是WindowProxy对象*/</span></span><br><span class="line">@property (readonly, strong) JSValue *globalObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当执行一个未定义的 JS 语句时，context会抛出异常。如果 exceptionHandler Block 不为 nil，则回调 block。否则，将异常静默保存到 exception 属性中*/</span></span><br><span class="line">@property (strong) JSValue *exception;</span><br><span class="line">@property (copy) <span class="keyword">void</span>(^exceptionHandler)(JSContext *context, JSValue *exception);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取与当前 context 关联的虚拟机 */</span></span><br><span class="line">@property (readonly, strong) JSVirtualMachine *virtualMachine;</span><br><span class="line"></span><br><span class="line">@property (copy) <span class="function">NSString *name <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ol>
<li><p>JSContext 执行 JS 代码</p>
<ul>
<li>调用<code>evaluateScript</code>函数可以执行一段<code>top-level</code> 的JS代码，并可向 global 对象添加函数和对象定义</li>
<li>其返回值是 JavaScript 代码中最后一个生成的值</li>
</ul>
</li>
<li><p>JSContext访问JS对象</p>
</li>
</ol>
<p>一个 JSContext 对象对应了一个全局对象（global object）。例如web浏览器中的 JSContext，其全局对象就是window 对象。在其他环境中，全局对象也承担了类似的角色，用来区分不同的JavaScript context的作用域，实际上JS代码都是在这个 GlobalObject 上执行的，但是为了容易理解，可以把 JSContext 等价于全局对象。</p>
<p>JavaScript 中的任何一个全局函数或变量都是 window 的属性。可以通过JSValue对象或者context下标的方式来访问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取上下文</span></span><br><span class="line">JSContext *context = [[JSContext alloc] init];</span><br><span class="line"><span class="comment">// 执行JavaScript代码并获取返回值</span></span><br><span class="line">[context evaluateScript:@<span class="string">"var a = 1 + 2;"</span>];</span><br><span class="line"><span class="comment">// 转换OC数据并打印</span></span><br><span class="line">NSLog(@<span class="string">"%@"</span>, [context objectForKeyedSubscript:@<span class="string">"a"</span>]);</span><br><span class="line">NSLog(@<span class="string">"%@"</span>, [context.globalObject objectForKeyedSubscript:@<span class="string">"a"</span>]);</span><br><span class="line">NSLog(@<span class="string">"%@"</span>, context[@<span class="string">"a"</span>]);</span><br><span class="line">NSLog(@<span class="string">"%@"</span>, context.globalObject[@<span class="string">"a"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>这里有三那种访问 JavaScript 对象的方法：</p>
<ul>
<li>通过 context 实例对象的 <code>objectForKeyedSubscript:</code>方法访问</li>
<li>通过 context.globalObject（JSValue类型）对象的<code>objectForKeyedSubscript:</code>方法访问</li>
<li>通过下标</li>
</ul>
<p>设置属性也是对应的操作</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* 为JSContext提供下标访问元素的方式 */</span><br><span class="line">@interface JSContext (SubscriptSupport)</span><br><span class="line"></span><br><span class="line">/* 首先将key转为JSValue对象，然后使用这个值在JavaScript context的全局对象中查找这个名字的属性并返回 */</span><br><span class="line">- (JSValue *)objectForKeyedSubscript:(id)key;</span><br><span class="line"></span><br><span class="line">/* 首先将key转为JSValue对象，然后用这个值在JavaScript context的全局对象中设置这个属性。</span><br><span class="line">可使用这个方法将native中的对象或者方法桥接给JavaScript调用 */</span><br><span class="line">- (void)setObject:(id)object forKeyedSubscript:(NSObject &lt;NSCopying&gt; *)key;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">/* 例如：以下代码在JavaScript中创建了一个实现是Objective-C block的function */</span><br><span class="line">    context[@"makeColor"] = ^(NSDictionary *rgb)&#123;</span><br><span class="line">        CGFloat red = [rgb[@"red"] floatValue];</span><br><span class="line">        CGFloat green = [rgb[@"green"] floatValue];</span><br><span class="line">        CGFloat blue = [rgb[@"blue"] floatValue];</span><br><span class="line">        return [UIColor colorWithRed:red/255.0 green:green/255.0 blue:blue/255.0 alpha:1];</span><br><span class="line">    &#125;;</span><br><span class="line">    // 执行JavaScript代码并获取返回值</span><br><span class="line">    JSValue *value = [context evaluateScript:@"makeColor(&#123;red:23, green:45, blue:89&#125;)"];</span><br><span class="line">    // 转换OC数据并打印</span><br><span class="line">    NSLog(@"%@", [value toObject]);</span><br><span class="line"></span><br><span class="line">// 输出结果</span><br><span class="line">UIExtendedSRGBColorSpace 0.0901961 0.176471 0.34902 1</span><br></pre></td></tr></table></figure>
<h3 id="JSValue"><a href="#JSValue" class="headerlink" title="JSValue"></a>JSValue</h3><p>一个 JSValue 实例就是一个JavaScript值的引用。是对 JS 值得包装，例如 JS 的 number，boolean等基本类型，也可以是对象，函数。对 JS 和 OC 应类型如下：</p>
<p><img src="/uploads/JavaScriptCore 解析/491.png" alt="img"></p>
<p>JSValue 是不能独立存在的，它必须存在于某一个 JSContext 中，一个 JSContext 中可以包含多个 JSValue。JSValue 对其对应的 JS 值和其所属的 JSContext 对象都是强引用的关系，只要有任何一个 JSValue 被持有（retain），对应的 JSContext就不会被销毁。</p>
<p>每个 JSValue 都通过其 JSContext 间接关联了一个特定的 JSVirtualMachine 对象。你只能将一个 JSValue 对象传给由相同虚拟机管理（host）的 JSValue 或者 JSContext 的实例方法。如果尝试把一个虚拟机的 JSValue 传给另一个虚拟机，将会触发一个Objective-C异常。<br><img src="/uploads/JavaScriptCore 解析/1492484878592_5842_1492484878973.png" alt="img"></p>
<h4 id="NSDictionary，NSArray-与-JS-对象"><a href="#NSDictionary，NSArray-与-JS-对象" class="headerlink" title="NSDictionary，NSArray 与 JS 对象"></a>NSDictionary，NSArray 与 JS 对象</h4><p>NSDictionary 对象以及其包含的 keys 与 JavaScript 中的对应名称的 Object类型对象 相互转换。</p>
<p>JS 中的对象可以直接转换成 Objective-C 中的 NSDictionary，NSDictionary传入 JavaScript 也可以直接当作对象被使用</p>
<p>NSArray 对象也是类似的转换方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    [context evaluateScript:@<span class="string">"var color = &#123;red:255, green:45, blue:89&#125;"</span>];</span><br><span class="line">    JSValue *value = context[@<span class="string">"color"</span>];</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>, [value toObject]);</span><br><span class="line">    </span><br><span class="line">    context[@<span class="string">"color"</span>] = @&#123;@<span class="string">"red"</span>:@<span class="number">33</span>, @<span class="string">"green"</span>:@<span class="number">100</span>, @<span class="string">"blue"</span>:@<span class="number">255</span>&#125;;</span><br><span class="line">    value = context[@<span class="string">"color"</span>];</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>, [value toObject]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">&#123;</span><br><span class="line">    blue = <span class="number">89</span>;</span><br><span class="line">    green = <span class="number">45</span>;</span><br><span class="line">    red = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    blue = <span class="number">255</span>;</span><br><span class="line">    green = <span class="number">100</span>;</span><br><span class="line">    red = <span class="number">33</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Block-函数-和-JS-function"><a href="#Block-函数-和-JS-function" class="headerlink" title="Block/函数 和 JS function"></a>Block/函数 和 JS function</h4><p>Objective-C中的block转换成 JavaScript 中的 function 对象。参数以及返回类型使用相同的规则转换。</p>
<p>将一个代表 native 的block或者方法的 JavaScript function 进行转换将会得到那个 block 或方法。</p>
<p>其他的 JavaScript 函数将会被转换为一个空的 dictionary。因为 JavaScript 函数也是一个对象。</p>
<h4 id="OC-对象和-JS-对象"><a href="#OC-对象和-JS-对象" class="headerlink" title="OC 对象和 JS 对象"></a>OC 对象和 JS 对象</h4><p>对于所有其他 native 的对象类型，JavaScriptCore 都会创建一个拥有 constructor 原型链的 wrapper 对象，用来反映native类型的继承关系。默认情况下，native对象的属性和方法并不会导出给其对应的 JavaScript wrapper 对象。通过 JSExport 协议可选择性地导出属性和方法。</p>
<h3 id="JSExport"><a href="#JSExport" class="headerlink" title="JSExport"></a>JSExport</h3><p>JSExport 协议提供了一种声明式的方法去向 JavaScript 代码导出 Objective-C 的实例类及其实例方法，类方法和属性。</p>
<h4 id="在-JavaScript-中调用-OC-代码"><a href="#在-JavaScript-中调用-OC-代码" class="headerlink" title="在 JavaScript 中调用 OC 代码"></a>在 JavaScript 中调用 OC 代码</h4><p>有两种方式：</p>
<ul>
<li>Block</li>
<li>JSExport 协议</li>
</ul>
<p>Block 的方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JSContext *context = [[JSContext alloc] init];</span><br><span class="line">context[@<span class="string">"add"</span>] = ^(NSInteger a, NSInteger b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一种调用 JS 函数的方法，直接通过 evaluateScript 调用</span></span><br><span class="line">JSValue *result = [context evaluateScript:@<span class="string">"add(3, 4)"</span>];</span><br><span class="line">NSLog(@<span class="string">"%@"</span>, [result toNumber]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种调用 JS 函数的方法，先获取对应的函数对象，在使用 callWithArguments 调用，并传入参数</span></span><br><span class="line">JSValue *value = context[@<span class="string">"add"</span>];</span><br><span class="line">JSValue *result = [value callWithArguments:@[@<span class="number">7</span>, @<span class="number">8</span>]];</span><br><span class="line">NSLog(@<span class="string">"%@"</span>, [result toNumber]);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>JSExport 的方式，需要通过继承 JSExport 协议的方式来导出指定的方法和属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个继承自 JSExport 的协议，在其中声明可以被 JS 导出的方法和属性</span></span><br><span class="line">@protocol GGJSExport&lt;JSExport&gt;</span><br><span class="line">@property (nonatomic, assign) CGFloat x;</span><br><span class="line">@property (nonatomic, assign) CGFloat y;</span><br><span class="line">- (CGFloat)add;</span><br><span class="line">+ (instancetype)JSObjectWithX:(CGFloat)x y:(CGFloat)y;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个类，遵守 GGJSExport 协议，实现协议中的方法和属性</span></span><br><span class="line"><span class="comment">// .h</span></span><br><span class="line">@interface GGJSObject : NSObject&lt;GGJSExport&gt;</span><br><span class="line">@property (nonatomic, assign) CGFloat x;</span><br><span class="line">@property (nonatomic, assign) CGFloat y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未在协议中声明的方法和属性，JS 无法识别</span></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">- (<span class="keyword">void</span>)doSomething;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line">@implementation GGJSObject</span><br><span class="line"></span><br><span class="line">- (CGFloat)add &#123;</span><br><span class="line">    <span class="keyword">return</span> self.x + self.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)JSObjectWithX:(CGFloat)x y:(CGFloat)y &#123;</span><br><span class="line">    GGJSObject *obj = [[GGJSObject alloc] init];</span><br><span class="line">    obj.x = x;</span><br><span class="line">    obj.y = y;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomething &#123;</span><br><span class="line">    NSLog(@<span class="string">"%@---%@"</span>, @(self.x), @(self.y));</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">JSContext *context = [[JSContext alloc] init];</span><br><span class="line">// 添加异常回调，在 js 调用异常时会回调次 block    </span><br><span class="line">context.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</span><br><span class="line">	NSLog(@"%@--------%@", context, exception);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 将实例对象和类导出给 context</span><br><span class="line">context[@"jsObject"] = [[GGJSObject alloc] init];</span><br><span class="line">context[@"GGJSObject"] = [GGJSObject class];</span><br><span class="line">// 属性赋值</span><br><span class="line">[context evaluateScript:@"jsObject.x = 100"];</span><br><span class="line">NSLog(@"x:%@", context[@"jsObject"][@"x"]);</span><br><span class="line"></span><br><span class="line">// 调用实例方法</span><br><span class="line">JSValue *result = [context evaluateScript:@"jsObject.add()"];</span><br><span class="line">NSLog(@"result:%@", result);    </span><br><span class="line"></span><br><span class="line">// 调用类方法   </span><br><span class="line">JSValue *classResult = [context evaluateScript:@"GGJSObject.JSObjectWithXY(20, 30)"];</span><br><span class="line">NSLog(@"obj:%@-----x:%@--------y:%@", [classResult toObject], classResult[@"x"], classResult[@"y"]);</span><br><span class="line"></span><br><span class="line">// 调用协议没有声明的方法，回触发异常，显示此方法未定义    </span><br><span class="line">[context evaluateScript:@"jsObject.doSomething()"];</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">x:100</span><br><span class="line">result:100</span><br><span class="line">obj:&lt;GGJSObject: 0x604000034280&gt;-----x:20--------y:30</span><br><span class="line">&lt;JSContext: 0x6040000486d0&gt;--------TypeError: jsObject.doSomething is not a function. (In 'jsObject.doSomething()', 'jsObject.doSomething' is undefined)</span><br></pre></td></tr></table></figure>
<ul>
<li>继承自 JSExport 的协议中，声明的类方法，实例方法和属性（如：<code>x</code>，<code>-add</code>，<code>+JSObjectWithX: y:</code>），都可以背 JS 获取到并且调用。未在协议中声明的方法或属性（如：<code>-doSomething</code>），则无法被 JS 获取到。</li>
<li>对于每一个导出的实例方法，JavaScriptCore 都会在 prototype 中创建一个存取器属性。对于每一个导出的类方法，JavaScriptCore会在 constructor 对象中创建一个对应的 JavaScript function。</li>
<li>在Objective-C中通过<code>@property</code>声明的属性决定了JavaScript中的对应属性的特征：<img src="/uploads/JavaScriptCore 解析/1492485215152_2649_1492485215481.png" alt="1492485215152_2649_1492485215481"></li>
<li>Objective-C类中的属性，成员变量以及返回值都将根据JSValue指定的拷贝协议进行转换。</li>
</ul>
<h4 id="函数名转换"><a href="#函数名转换" class="headerlink" title="函数名转换"></a>函数名转换</h4><p>转换成驼峰形式：</p>
<ul>
<li>去掉所有的冒号</li>
<li>所有冒号后的第一个小写字母都会被转为大写</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// oc 方法</span></span><br><span class="line">JSObjectWithX: y:</span><br><span class="line"><span class="comment">// 对应 JS function</span></span><br><span class="line">JSObjectWithXY(x, y)</span><br></pre></td></tr></table></figure>
<p>如果不喜欢默认的转换规则，也可以使用 JSExportAs 进行自定义转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// JSExportAs 的宏定义（JSExport.h）</span><br><span class="line">#define JSExportAs(PropertyName, Selector) \</span><br><span class="line">    @optional Selector __JS_EXPORT_AS__##PropertyName:(id)argument; @required Selector</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// 	在协议中自定义声明</span><br><span class="line">@protocol GGJSExport&lt;JSExport&gt;</span><br><span class="line">JSExportAs(JSObject, + (instancetype)JSObjectWithX:(CGFloat)x y:(CGFloat)y);</span><br><span class="line">//+ (instancetype)JSObjectWithX:(CGFloat)x y:(CGFloat)y;</span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">// 调用</span><br><span class="line">[context evaluateScript:@&quot;GGJSObject.JSObject(20, 30)&quot;];</span><br></pre></td></tr></table></figure>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>当声明一个继承自 JSExport 的自定义协议时，就是在告诉 JSCore，这个自定义协议中声明的属性，实例方法和类方法需要被暴露给JS使用。（不在这个协议中的方法不会被暴露出去。）</p>
<p>当把实现这个协议的类的对象暴露给 JS 时，JS 中会生成一个对应的 JS 对象，然后，JSCore会按照这个协议中声明的内容，去遍历实现这个协议的类，把协议中声明的属性，转换成 JS 对象中的属性，实质上是转换成 getter 和 setter 方法，转换方法和之前说的block类似，创建一个JS方法包装着OC中的方法，然后协议中声明的实例方法，转换成 JS 对象上的实例方法，类方法转换成 JS 中某个全局对象上的方法。</p>
<p> <img src="/uploads/JavaScriptCore 解析/599.png" alt="img"></p>
<h3 id="JSManagedValue"><a href="#JSManagedValue" class="headerlink" title="JSManagedValue"></a>JSManagedValue</h3><h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>由于每个 JSValue 对其对应的 JS 值和其所属的 JSContext 对象都是强引用的关系，只要有任何一个 JSValue 被持有（retain），对应的 JSContext就不会被销毁。如果我们将一个 native 对象导出给 JavaScript，即将这个对象交由JavaScript 的全局对象持有，引用关系如下：</p>
<p><img src="/uploads/JavaScriptCore 解析/1492486033041_8675_1492486033267.png" alt="1492486033041_8675_1492486033267"></p>
<p>如果我们在 native 对象（如Block）中强引用持有 JSContext 或者 JSValue，便会造成循环引用：</p>
<p><img src="/uploads/JavaScriptCore 解析/1492486061808_9327_1492486062018.png" alt="1492486061808_9327_1492486062018"></p>
<p>因此在使用时要注意：</p>
<ul>
<li><p>避免直接使用外部context</p>
<ul>
<li>避免在导出的 block/native 函数中直接使用 JSContext</li>
<li>使用 [JSContext currentContext] 来获取当前context能够避免循环引用</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误用法</span></span><br><span class="line">context[@<span class="string">"block"</span>] = ^() &#123;</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>, context);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纠正用法</span></span><br><span class="line">context[@<span class="string">"block"</span>] = ^() &#123;</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>, [JSContext currentContext]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>避免直接使用外部JSValue</p>
<ul>
<li>避免在导出的 block/native 函数中直接使用 JSValue</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误用法</span></span><br><span class="line">JSValue *value = [JSValue valueWithObject:@<span class="string">"test"</span> inContext:context];</span><br><span class="line">context[@<span class="string">"block"</span>] = ^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>, value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纠正用法，使用 JSManagedValue 来解决问题</span></span><br><span class="line">JSValue *value = [JSValue valueWithObject:@<span class="string">"test"</span> inContext:context];</span><br><span class="line">JSManagedValue *managedValue = [JSManagedValue managedValueWithValue:value andOwner:self];</span><br><span class="line">context[@<span class="string">"block"</span>] = ^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>, [managedValue value]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="JSManagedValue-1"><a href="#JSManagedValue-1" class="headerlink" title="JSManagedValue"></a>JSManagedValue</h4><p>一个JSManagedValue对象包含了一个JSValue对象，“有条件地持有（conditional retain）”的特性使其可以自动管理内存。</p>
<p>所谓“有条件地持有（conditional retain）”，是指在以下两种情况任何一个满足的情况下保证其管理的 JSValue 被持有：</p>
<ul>
<li><p>可以通过 JavaScript 的对象图找到该 JSValue</p>
</li>
<li><p>可以通过 native 对象能找到该 JSManagedValue。</p>
</li>
</ul>
<p>使用 <code>addManagedReference:withOwner:</code> 方法可向虚拟机记录该关系。反之，如果以上条件都不满足，JSManagedValue 对象就会将其 value 置为 nil 并释放该 JSValue。JSManagedValue 对其包含的 JSValue 的持有关系与ARC下的虚引用（weak reference）类似。</p>
<p>通常我们使用 weak 来修饰 block 内需要使用的外部引用以避免循环引用，由于 JSValue 对应的JS对象内存由虚拟机进行管理并负责回收，这种方法不能准确地控制block内的引用JSValue的生命周期，可能在block内需要使用JSValue的时候，其已经被虚拟机回收。所以做好不使用 weak 引用，而是使用 JSManagedValue。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用 JSVirtualMachine 手动管理</span></span><br><span class="line">- (<span class="keyword">void</span>)addManagedReference:(id)object withOwner:(id)owner;</span><br><span class="line">- (<span class="keyword">void</span>)removeManagedReference:(id)object withOwner:(id)owner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用 JSManagedValue 的类方法直接产生一个带owner的对象</span></span><br><span class="line">+ (JSManagedValue *)managedValueWithValue:(JSValue *)value andOwner:(id)owner;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1004875" target="_blank" rel="external">JavaScriptCore全面解析 （上篇）</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1004876" target="_blank" rel="external">JavaScriptCore全面解析（下篇）</a></p>
<p><a href="https://www.jianshu.com/p/ac534f508fb0" target="_blank" rel="external">深入浅出 JavaScriptCore</a></p>
<p><a href="https://link.jianshu.com/?t=https://developer.apple.com/videos/play/wwdc2013/615/" target="_blank" rel="external">Integrating JavaScript into Native Apps</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS项目Project和Target配置详解]]></title>
      <url>http://liugangqiang.com/2018/03/22/iOS%E9%A1%B9%E7%9B%AEProject%E5%92%8CTarget%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>iOS 项目一般使用 Xcode 进行开发。项目创建完成后，点击项目名称，在项目导航栏的右侧板面上显示有 PROJECT 和 TARGETS 两部分。iOS 项目的开发环境搭建主要就是基于我们项目的 Project 和 Target 进行展开的，下面对这两部分进行详解，<a href="https://developer.apple.com/library/content/featuredarticles/XcodeConcepts/Concept-Projects.html#//apple_ref/doc/uid/TP40009328-CH5-SW1" target="_blank" rel="external">参考官方文档</a>。</p>
<p><img src="/uploads/iOS项目Project和Target配置详解/ProjectAndTargets_01.jpeg" alt=""></p>
<a id="more"></a>
<h1 id="Project、Target、Build-Settings、Workspace和Scheme"><a href="#Project、Target、Build-Settings、Workspace和Scheme" class="headerlink" title="Project、Target、Build Settings、Workspace和Scheme"></a>Project、Target、Build Settings、Workspace和Scheme</h1><h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><p>一个 project 是构建一个或多个软件产品所需的所有文件、资源、信息/配置的存储库（repository）。一个 project 包含所有用于构建产品（build your products）的元素，并维护这些元素之间的关系。它可以包含一个或多个 Targets。一个project 为所有的 targets 定义默认的 build setting（每一个 target 可以自定义它们的 build setting，这些自定义的 setting会覆盖 project 默认的 build setting）。</p>
<p>一个 Xcode project 文件包含以下几部分信息：</p>
<ul>
<li>相关源文件（source files）<ul>
<li>源代码，包括 .h 和 .m 文件</li>
<li>libraries 和 frameworks，内部的和外部的</li>
<li>资源文件</li>
<li>图片资源文件</li>
<li>nib 文件</li>
</ul>
</li>
<li>用于在结构导航器（ structure navigator）中组织源文件（source files）的组（groups）</li>
<li>Project-level build configurations（项目级构建配置），可以有多个，例如 debug 和 release buid setting</li>
<li>Targets，每个 target 指定：<ul>
<li>通过 project 构建一个产品（product）的引用</li>
<li>构建该产品（product）所需要的资源文件的引用</li>
<li>用于构建该产品（product）的构建配置（build configurations），包括对其他 Targets 和 settings 的依赖；如果 targets 的 build configurations 没有配置时，使用 Project-level build configurations</li>
</ul>
</li>
<li>用来 debug 和 test 程序的可执行环境，包括：<ul>
<li>从 Xcode run 或 debug 时启动的可执行文件</li>
<li>要传递给可执行文件的命令行参数</li>
<li>程序 run 时要设置的环境变量</li>
</ul>
</li>
</ul>
<p>一个 project 可以单独存在，也可以包含在一个 workspace 里。</p>
<h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>一个 target 确定一个产品（product）的构建，包括一些指令（instructions）——怎么从一个 project 或者 workspace 的一堆文件导出一个产品。一个 target 对应一个 product，它管理着一个 product 的 build system 的“输入”（一堆源文件和一些处理这些源文件的 instruction）。一个 project 可以包含多个 target，每一个 targe 生成一个 product。</p>
<p>构建一个 product 的 instructions （指令）的表现形式是 build settings 和 build phases，可以在 Xcode project editor 中检查和编辑。一个 target 的 build settings 继承 project 的 build settings，但是可以重写覆盖 project settings。同一时间里只有一个 active target ，由 Xcode Scheme 指定。</p>
<p>一个 target 和它创建的 product 可以跟其他 target 关联。如果一个 target 需要另一个的 <code>output</code>以完成构建，可以说成第一个 target 依赖第二个。</p>
<p>如果两个 targets 在同一个 workspace 中，Xcode 可以发现他们的依赖关系，从而 builds the products 按照特定的顺序。这样的关系被称为“implicit dependency（隐式依赖）”。可以为俩个 targets 指定明确的依赖或者不依赖关系在 build setting 里面。</p>
<p>例如：在同一个 workspace 中，可以构建一个 library 和一个链接这个 library 的 application。Xcode 可以发现这种依赖关系，并首先自动构建 library。但是，如果想链接某个版本的 library，就需要在  build settings 明确依赖关系，该依赖项会覆盖隐式依赖项。</p>
<h2 id="Build-Settings"><a href="#Build-Settings" class="headerlink" title="Build Settings"></a>Build Settings</h2><p>一个 build Setting 是一个变量，包含着怎么 build product 的处理信息。例如，可以指定 Xcode 传递给编译器的选项</p>
<p>Build settings 有 project 和 target 两个级别，project－level 中的 build setting 适用项目中所有的 targets，只要该项 setting 没有被 target 级别的重写覆盖。</p>
<p>每个 target 管理着创建一个 product 的源文件，一个 build configuration 指定一组 build settings，用于以特定的方式构建一个 product。例如，通常有 debug 和 release 俩种分开的 build configurations。</p>
<p>一个 build Setting 包含两个部分：setting title（标题） 和 definition（定义）——类似于 key-value 结构。前者标示该 build Setting，并且可以被用在其他的settings。后者是一个常量或一个表达式，用于确定 build setting 的值。一个 build setting 也可以有一个显示名称，被用于在 Xcode 界面中显示 build setting。</p>
<p>另外，当你通过 project 模板新建一个 project 时，Xcode 会生成一个默认的 build settings，你也可以为 project 或者某个 target 创建自定义build settings。你还可以设定 conditional build settings，一个 conditional build setting 的值取决于是否满足一个或多个先决条件。这个机制也可以被用在指定用于基于目标架构构建产品的SDK。</p>
<h2 id="Workspace"><a href="#Workspace" class="headerlink" title="Workspace"></a>Workspace</h2><p>一个 workspace 是一个 Xcode 文档，groups(组合)不同的project、文档，所以你可以同时管理多个project。一个 workspace 可以包含任意数量的 Xcode projects 和其他文件。除了组织每个 Xcode projects 中的所有文件外，workspace 还提供 projects 与他们各自 targets 之间的隐式/显示关联。</p>
<h3 id="Workspace-扩展-workflows-的范围"><a href="#Workspace-扩展-workflows-的范围" class="headerlink" title="Workspace 扩展 workflows 的范围"></a>Workspace 扩展 workflows 的范围</h3><p>一个工程文件（project file）包含指向 project 中所有文件的指针，build configurations 和 project 的其他信息。在Xcode 3 之前，projects 之前关联是很复杂的事情，大多数工作流仅限于单个 project。从 Xcode 4 之后，你可以创建一个 workspace 去包含多个 projects 和其他文件。</p>
<p>除了提供被包含在 Xcode project 中的所有文件的访问外，workspace 还拓展许多重要的 Xcode workflows 的范围。例如，由于 indexing（文件索引）遍布整个 workspace，所以，在 workspace 中， code completion、Jump to Definition 和所有其他的内容感知特性，可以在所有 projects 中无缝衔接运作。因为 refactoring operations（重构操作）横跨整个 workspace 的所有内容，所以，你可以在一个 framework project 中重构 API，并且在其他 application projects 中使用这个 framework。构建时，一个 project 可以利用 workspace 中其他 projects 的 products。</p>
<p>workspace 文档包含被囊括的 projects 和其他文件，不再有其他数据。一个 project 可以被多个 workspace 持有。下图展示一个 workspace 包含两个 Xcode projects 以及 一个文档 project。</p>
<p>备注：workspace 类似.xcodeproj文件，他不是一个文件夹，而是一个有管理、索引作用的一个文件。</p>
<p><img src="/uploads/iOS项目Project和Target配置详解/ProjectAndTargets_02.jpg" alt=""></p>
<h3 id="Workspaces-中的-Projects-共享-Build-Directory"><a href="#Workspaces-中的-Projects-共享-Build-Directory" class="headerlink" title="Workspaces 中的 Projects 共享 Build Directory"></a>Workspaces 中的 Projects 共享 Build Directory</h3><p>默认情况下，workspace 中的所有 Xcode projects 都构建在同一目录中（称为工作区构建目录 - works pace build directory）。每一个 workspace 都有自己的 build directory。因为 workspace 中 所有 projects 的所有文件都唯一同一个  build directory，所以所有这些文件对每个项目都是可见的。因此，如果两个或多个 projects 使用同一个 library（库），你不需要把他们分别复制到每个 project 文件夹中。</p>
<p>Xcode 会检查 build directory 里的文件并发现其中的隐式依赖关系（implicit dependencies）。例如，workspace 中包含的一个 project 生成的库，被另一个 project 引用，Xcode 会在生成另一个 project 之前自动生成这个库，即使 build configuration 未标明这种显示依赖（dependency explicit）。如果需要，你可以进行显示设置覆盖这种隐式依赖。对于“显示依赖”，你必须创建项目引用。</p>
<p>workspace 中的每一个 project 都有保持自己的特性。你能通过 project 的打开方式控制 project 受不受其他 projects 的影响，如单独打开 project 而不是通过 workspace。由于 project 可以属于多个 workspace，您可以以任意数量的组合来处理 projects，而不必重新配置任何 project 或 workspace。</p>
<p>你可以使用 workspace 默认的 build directory，也可以自己指定一个。注意：如果一个 project 指定一个 build directory，这个 build directory 会覆盖全部所在的 workspace 里的默认 build directory。</p>
<h2 id="Xcode-Scheme"><a href="#Xcode-Scheme" class="headerlink" title="Xcode Scheme"></a>Xcode Scheme</h2><p>一个 Xcode Scheme（方案）定义三样东西：一个要生成的目标（targets to build）的集合、building 时使用的配置（configuration）、以及要执行的测试集合。</p>
<p>你可以拥有任意数量的 scheme，但一次只能有一个是活跃状态（active），你可以指定 scheme 是否储存在 project 中（这种方案下，scheme 在每一个包含这个 project 的 workspace 中都可用），或者储存在 workspace 中（仅在当前 workspace 中可用）。选择要激活的 scheme 时，可以选择运行目标（设备）。</p>
<h1 id="Project-和-Target-的属性设置"><a href="#Project-和-Target-的属性设置" class="headerlink" title="Project 和 Target 的属性设置"></a>Project 和 Target 的属性设置</h1><p>Project 和 Target 的属性设置，如下边两张图所示，上边一张是 project 的，只包含 <code>Info</code> 和 <code>Build Settings</code> 两个选项卡，只是对项目资源进行简单的设置；下边是 target 的，包含 <code>General</code>、<code>Capabilities</code>、<code>Resource tags</code>、 <code>Info</code>、<code>Build Settings</code>、<code>Build phases</code>和<code>Build rules</code>七个选项卡，比较复杂，每一项都直接决定了我们最终 App（product）的显示效果。</p>
<p><img src="/uploads/iOS项目Project和Target配置详解/ProjectAndTargets_03.png" alt="project 属性示意图"></p>
<p><img src="/uploads/iOS项目Project和Target配置详解/ProjectAndTargets_04.png" alt="target 属性示意图"></p>
<h2 id="Project-属性"><a href="#Project-属性" class="headerlink" title="Project 属性"></a>Project 属性</h2><p>Project 的属性包含<code>Info</code> 和 <code>Build Settings</code> 两个选项卡的内容，但是 target 的<code>Build Settings</code>和 project 的是关联的，会继承部分 project 的<code>Build Settings</code>的属性，这里主要讲解<code>Info</code> ，<code>Build Settings</code>后面与 target 的一起讲解。</p>
<h3 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h3><p><code>Info</code>主要包括三部分内容：<code>Deployment Target</code>、<code>Configurations</code>和 <code>Localizations</code>。 </p>
<p><img src="/uploads/iOS项目Project和Target配置详解/ProjectAndTargets_03.png" alt="Image_03"></p>
<h4 id="1-Deployment-Target"><a href="#1-Deployment-Target" class="headerlink" title="1. Deployment Target"></a>1. <code>Deployment Target</code></h4><p>部署配置，主要是本 project 生成的 APP 的可运行的最低版本进行配置，默认是当前 Xcode 上 API 的最新版本。所以，在我们的项目中有需要对低版本适配的地方可以在这里设置。同样的，我们还可以在<code>build setting</code>中对这一属性进行设置，两者是同步的。target 的 <code>General</code>-&gt;<code>Deployment Info</code>-&gt;<code>Deployment Target</code>默认继承此属性，手动修改则覆盖此属性。</p>
<h4 id="2-Configurations"><a href="#2-Configurations" class="headerlink" title="2. Configurations"></a>2. <code>Configurations</code></h4><p>用来配置 iOS 项目的<code>xcconfig</code>文件，主要用于在几套不同的开发环境编译。<code>xcconfig</code>文件其实就是 Xcode 里的<code>config</code>文件，本质是一个用来保存<code>Build Settings</code>键值对的<strong>纯文本文件</strong>。这些键值对会覆盖<code>Build Settings</code>中的值，所以当在<code>xcconfig</code>文件中配置了的选项，在<code>Build Settings</code>中设置将失效。具体使用<a href="https://www.jianshu.com/p/b1b6255ff3ee" target="_blank" rel="external">参照这里</a>。项目中一般不会进行<code>xcconfig</code>文件的自定义。</p>
<p>Cocoapods 的项目配置管理很多都是依赖<code>xcconfig</code>文件去实现的。所以在使用 Cocoapods 进行导包的项目中，我们通过打开.xcworkspace 文件，我们会发现<code>Project</code>—&gt;<code>Info</code>—&gt;<code>Configutations</code>下的都有对应的配置文件，而原先没有用 Cocoapods 配置的则没有相关的配置文件，具体区别如下图所示。</p>
<p><img src="/uploads/iOS项目Project和Target配置详解/ProjectAndTargets_06.png" alt="ProjectAndTargets_06"></p>
<p><img src="/uploads/iOS项目Project和Target配置详解/ProjectAndTargets_05.png" alt="ProjectAndTargets_05"></p>
<h4 id="3-Localizations"><a href="#3-Localizations" class="headerlink" title="3. Localizations"></a>3. <code>Localizations</code></h4><p>本地化，这里的功能主要是添加我们的App所支持的语言，通过<code>Localizations</code>选项下面的【+】【-】按钮可以添加或删除不同的语种，并可以选择根据手机的设置进行不同语种的自适应。关于最下面的选择是否开启国际化，默认是开启的，至于如何进行国际化和不同语种的适配详情见：<a href="http://www.cocoachina.com/ios/20151120/14258.html" target="_blank" rel="external">详述iOS国际化</a>。</p>
<h3 id="Build-Settings-1"><a href="#Build-Settings-1" class="headerlink" title="Build Settings"></a>Build Settings</h3><p>与下面 Target 的 <code>Build Settings</code>一起介绍</p>
<h2 id="Target-的属性"><a href="#Target-的属性" class="headerlink" title="Target 的属性"></a>Target 的属性</h2><p>Target 的属性设置的内容比较多，总共有<code>General</code>、<code>Capabilities</code>、<code>Resource tags</code>、<code>Info</code>、<code>Build setting</code>、<code>Build phases</code>和<code>Build rules</code>七个选项卡。</p>
<h3 id="General"><a href="#General" class="headerlink" title="General"></a>General</h3><p><code>General</code>主要包括六部分内容：<code>Identity</code>、<code>Signing、</code> <code>Deployment Info</code>、<code>App Icons and Launch Images</code>、<code>Embedded Binaries</code>和<code>Linked Frameworks and Libraries</code>。 </p>
<h4 id="Identity"><a href="#Identity" class="headerlink" title="Identity"></a><code>Identity</code></h4><p>标识符，栏主要定义了一些和应用发布有关的标识属性</p>
<ul>
<li>Display Name：App 应用显示名字，安装到iOS手机或iPad上App的名称。</li>
<li>Bundle Identifier：包标识符，是该应用唯一的 ID，用来让操作系统和AppStore识别。在创建项目或者对象过程中Xcode 就自行创建了包标识符，一般情况下不要修改它。一般以公司域名倒序+App名称进行命名。</li>
<li>Version：外部版本号，使用户能看到的版本号。</li>
<li>Build：内部版本号，开发者自己看到的版本号，以区分内部测试版本。</li>
</ul>
<h4 id="Signing"><a href="#Signing" class="headerlink" title="Signing"></a><code>Signing</code></h4><p>签名，进行证书管理在真机调试或者打包时都需要进行签名进行认证才可以。</p>
<ul>
<li>Automatically manage signing：Xcode 8推出的自动签名功能，可以直接使用 Xcode 把 App 打包到真机上去测试，<a href="https://blog.csdn.net/java3182/article/details/78885145" target="_blank" rel="external">具体使用参考</a>。</li>
<li>Team：开发团队，即开放者账号名称。</li>
<li>Provisioning Profile：提供的配置文件。</li>
<li>Signing Certificate：签名证书</li>
</ul>
<h4 id="Deployment-Info"><a href="#Deployment-Info" class="headerlink" title="Deployment Info"></a><code>Deployment Info</code></h4><p>部署信息，定义了一些和应用配置相关的标识属性</p>
<ul>
<li>Deployment Target：部署对象，用来设置支持的最低版本。这个和 project 的<code>info</code>中的一个意思，并且，这两个的设置最好是一样，如果不一样，最后的App会以target的设置为准。</li>
<li>Devices：设备，设置支持的设备，有iPhone、iPad和Universal（通用）三个选项。</li>
<li><p>Main Interface：主界面，应用启动时预加载的主界面视图。一般有两种方法：</p>
<ol>
<li>一种是通过 Main.storyboard 进行启动，设置这种方法需要我们整个项目的逻辑和跳转都在 Main.storyboard 中完成</li>
<li>取消<code>stroryboard</code>的方式启动主界面，而是通过代码的方式运行main.m的方法进行启动，并通过在AppDelegate的 - (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions 方法中指定主界面视图进行启动。<strong>一般项目中都是采用这种方法进行的，因为一般项目中界面比较多，很多都是通过纯代码的风格进行定义的，这样方便修改和定位问题，项目的逻辑也更清晰，特别是多人合作的项目，这种风格更适合</strong></li>
</ol>
</li>
<li><p>Device Orientation：设备方向，定义应用支持的方向。有Portrait（正向）、Upside Down（倒置）、Landscape Left（横评、Home键在左）、Landscape Right（横评、Home键在右）四种方向。</p>
</li>
<li>Status Bar Style：状态栏状态，设置 App 启动时状态栏的状态，可设置为 Default（默认黑色）、Light（白色）。还可以设置是否隐藏，是否要全屏启动。尽在 App 启动时有效，启动完成后效果过期。</li>
</ul>
<h4 id="App-Icons-and-Launch-Images"><a href="#App-Icons-and-Launch-Images" class="headerlink" title="App Icons and Launch Images"></a><code>App Icons and Launch Images</code></h4><p>应用图标和启动页面。主要设置三项：应用图标、启动图片和启动页面。具体应用图标和启动页面的大小尺寸介绍见官网：<a href="https://developer.apple.com/ios/human-interface-guidelines/icons-and-images/app-icon/" target="_blank" rel="external"><strong>Human Interface Guidelines</strong></a>。</p>
<ul>
<li>App Icons Source：应用图标，对应着文件资源 Assets.xcassets 目录中的 AppIcon 中的图片。最右边的面板可以选择添加哪一种或哪几种设备上的图标，每一个型号的设备上的图标的尺寸是不同的。在中间有一个个的小格子，我们将所有切好的图标直接拖过来，他们会自动找到自己应该放在的格子里。这些小格子主要分为四类：<ol>
<li>Notification：通知时的图标，类似有应用相关的推送消息时，有时候需要显示本应用的图标则会显示这个尺寸的</li>
<li>Spotlight：搜索小图标，当在Spotlight中输入应用名，搜索结果中出现该应用时的图标就是这个尺寸的，还有设置里的图标也是这个尺寸的。</li>
<li>App：这就是正常的App图标，安装好之后在桌面显示的，或者分享推荐时显示的应用也是这个尺寸的图标</li>
<li>App store：应用商店中的显示的图标</li>
</ol>
</li>
</ul>
<p><img src="/uploads/iOS项目Project和Target配置详解/ProjectAndTargets_08.png" alt=""></p>
<ul>
<li>Luanch Image Source：启动图片，同样对应着文件资源Assets.xcassets目录中的LuanchImage中的图片，设定了各种情况下的启动图片，和 Appicon 一样，我们将所有切好的图标直接拖过来，他们会自动找到自己应该放在的格子里。<strong>启动图片实际上定义了应用启动后的界面大小</strong>，所以在不同机型中我们需要做好适配，见下面的【启动页面在屏幕适配中的作用】。一款App必须设定对应设备的启动图片，否则点开应用会是一片黑色。</li>
<li>Luanch Screen File：启动页面文件，是一个storyboard文件，作用与 Luanch Image 一样，但是启动文件的优先级高于启动图片，就是说如果两个都设置了，那么启动页面以启动文件为准，如果都没有设置，则启动时是一片黑色。<ul>
<li>启动页面的作用：在我们点击应用图标启动应用时，应用启动需要一定的操作时间，再启动期间，为了增强应用程序启动时的用户体验，您应该提供一个启动图像。启动图像与应用程序的首屏幕看起来非常相似。当用户在主屏幕上点击您的应用程序图标时，iPhone OS会立即显示这个启动图像。一旦准备就绪，您的应用程序就会显示它的首屏幕，来替换掉这个启动占位图像。一定要强调的是，之所以提供启动图像，是为了改善用户体验，并不是为了提供：应用程序进入体验，比如启动动画。</li>
<li>启动页面在屏幕适配中的作用：每个机型，比如同时支持 iPhone 和 iPad的 程序，需要分别为 iPhone 跟 iPad 指定启动图片。当旧的 iPhone 4 的程序，运行在 iPhone 5 上面，没有iPhone 5的启动图片，就采用兼容模式，上下留黑边。当为 iPhone 5 指定了新的启动图片，系统就认为这个应用程序是已经适配了iPhone 5的。当旧的iPhone 5程序运行在iPhone 6上面，假如没有经过适配。旧程序自动等比放大，铺满新手机，旧程序也可以正常运行。这种方案可算是自动适配。但因为旧程序拉伸了，整体看起来有点虚，也不能更好利用大屏空间。当需要开发者手动适配的时候，跟iPhone 4过渡到iPhone 5一样，在新程序中，指定一张新的启动图片。当指定了启动图，系统就认为应用已经做好了屏幕适配，屏幕分辨率就变成应有的大小。在某机型上，<strong>如果是自动适配，比如iPhone 5，老版程序就会在屏幕上、下俩端多出俩块黑条；比如iPhone6/6plus，老版程序就会自动等比拉伸</strong>。那如何关闭自动适配？指定启动图或者使用Launch Screen File.xib，即程序使用手动适配，不会做拉伸等，但是程序内部必须已做处理，否则使用自动适配方案。</li>
</ul>
</li>
</ul>
<h4 id="Embedded-Binaries"><a href="#Embedded-Binaries" class="headerlink" title="Embedded Binaries"></a><code>Embedded Binaries</code></h4><p>绑定二进制文件，用来连接二进制文件，一般在使用第三方SDK的时候使用。</p>
<h4 id="Linked-Frameworks-and-Libraries"><a href="#Linked-Frameworks-and-Libraries" class="headerlink" title="Linked Frameworks and Libraries"></a><code>Linked Frameworks and Libraries</code></h4><p>链接的框架和库，选择要链接的框架和库，既可以是SDK自带的框架，也可以是第三方框架，在 Build Phases 中也有相同的功能选项。</p>
<h3 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h3><p>target 的 Capabilities 属性设置这一块主要是一些性能设置开关选择，例如推送通知、云存储、游戏中心、后台模式等，我们选择需要的开关进行打开或者关闭，这些相应的状态都会在 info.plist 中进行修改。所以，同样的，我们也可以在info.plist添加一些权限或性能开关之后，在target的capabilities中也会进行相应的修改的。</p>
<h3 id="Resource-Tag"><a href="#Resource-Tag" class="headerlink" title="Resource Tag"></a>Resource Tag</h3><p>Target 中的 Resource Tag 选项卡主要是为项目中的资源进行添加 tag 分类。方便我们对其加载顺序和加载时机进行选择和设置，即实现按需加载，在需要的时候才加载资源。按需加载资源是由App Store托管的内容，它和下载的 App bundle是分开的。App请求一系列按需加载资源，而下载和存储资源是由操作系统来管理。这些资源可以是除可执行代码外，bundle 支持的任何类型。这样做的好处就是可以实现如下几种资源加载形式：</p>
<ul>
<li><strong>初始资源的延迟加载。</strong>app有一些资源是主要功能要用到的，但在启动时并不需要。将这些资源标记为“初始需要”。操作系统在app启动时会自动下载这些资源。例如，图片编辑app有许多不常用的滤镜。</li>
<li><strong>app资源的延迟加载。</strong>app有一些只在特定情景下使用的资源，当应用可能要进入这些场景时，会请求这些资源。例如，在一个有很多关卡的游戏中，用户只需要当前关卡和下一关卡的资源。 </li>
<li><strong>不常用资源的远程存储。</strong>app有一些很少使用的资源，当需要这些资源时会去请求它们。例如，当app第一次打开时会展示一个教程，而这个教程之后就可能不会在用到。app在第一次启动时请求教程的资源，这之后只在需要展示教程或者添加了新功能才去请求该资源。</li>
<li><strong>应用内购买资源的远程存储。</strong>app提供包含额外资源的应用内购买。app会在启动完成后请求已购买模块的资源。例如，用户在一个键盘app内购买了SuperGeeky表情包。应用程序会在启动完成后请求表情包的资源。</li>
</ul>
<p><img src="/uploads/iOS项目Project和Target配置详解/ProjectAndTargets_09.png" alt="18.png"></p>
<p>在 Resource Tags 选项卡的 Prefetched 界面下，可以把 tag 分配给三个预获取优先级分类的其中一个。界面展示了按预获取分类分组的 tag。tag 可以在分类间拖动。</p>
<ul>
<li><strong>初始安装tag（Initial install tags）</strong>。只有在初始安装tag下载到设备后，app才能启动。这些资源会在下载app时一起下载。这部分资源的大小会包括在App Store中app的安装包大小。如果这些资源从来没有被NSBundleResourceRequest 对象获取过，就有可能被清理掉。</li>
<li><strong>按顺序预获取tag（Prefetch tag order）</strong>。在app安装后会开始下载tag。tag会按照此处指定的顺序来下载。 </li>
<li><strong>按需下载（Dowloaded only on demand）</strong>。当app请求一个tag，且tag没有缓存时，才会下载该tag。</li>
</ul>
<p>关于Resource Tag和按需加载的详情内容和步骤参见下面两篇文章：</p>
<ul>
<li><a href="http://www.cocoachina.com/ios/20150615/12155.html" target="_blank" rel="external">On-Demand Resources Guide中文版（按需加载资源–上）</a></li>
<li><a href="http://www.cocoachina.com/ios/20150615/12152.html" target="_blank" rel="external">On-Demand Resources Guide中文版（按需加载资源—下）</a></li>
</ul>
<h3 id="Info-1"><a href="#Info-1" class="headerlink" title="Info"></a>Info</h3><p>Target 的 Info 属性设置界面如下图所示，主要分为五个部分<code>Custom iOS Target Properties</code>、<code>Docunment Types</code>、<code>Exported UTIs</code>、<code>Imported UTIs</code>、<code>URL types</code>。</p>
<p><img src="/uploads/iOS项目Project和Target配置详解/926487-20180121192046818-1861518679.png" alt="img"></p>
<h4 id="Custom-iOS-Target-Properties"><a href="#Custom-iOS-Target-Properties" class="headerlink" title="Custom iOS Target Properties"></a><code>Custom iOS Target Properties</code></h4><p>自定义 iOS 属性，Target 的 Info 属性里最重要的一项。在 target 的 Info 选项卡中的此项信息与我们项目资源目录下的 info.plist 文件中的内容是一致，并且修改其中一个另一个会自动修改。此外，<code>General</code> 选项卡中的一些设置也会对应到 info.plist 文件中，所以这些内容都是相通的，我们修改一处，其他的地方会同步修改。info.plist 中其实加载的信息会非常多，上面是创建项目之后自动生成的一些最基本的设置选项，每一项对应的意思如下解释：</p>
<ul>
<li>Localization native development region ： 与本地化设置有关，为默认的开发语言</li>
<li>Executable file：程序安装包的名称</li>
<li>Bundle identifier：软件唯一的标识，是根据公司的标识与项目名称自动生成的，在上传和测试的时候会用到</li>
<li>InfoDictionary version：版本信息</li>
<li>Bundle name：App安装后显示的名称</li>
<li>Bundle OS Type code：用来标识软件包类型</li>
<li>Bundle versions string, short：发布的版本字符串</li>
<li>Bundle creator OS Type code：创建者的标识</li>
<li>Bundle version：应用程序版本号</li>
<li>Application requires iPhone environment：用于指示程序包是否只能运行在iPhone OS 系统上，默认为YES</li>
<li>Launch screen interface file base name：欢迎界面的文件名称</li>
<li>Main storyboard file base name：默认情况下程序的主入口</li>
<li>Supported interface orientations：设置程序默认支持的方向</li>
</ul>
<p>除此之外，我们在开发过程可能还需要添加一些其他的信息，包括一些权限的添加，网络权限、定位权限、读写联系人权限等等，应用白名单的添加等都是在这里进行配置的。关于 info.plist 的具体信息和内容详情参见：<a href="http://www.cocoachina.com/ios/20160922/17611.html" target="_blank" rel="external"><strong>Xcode中的Info.plist字段列表详解</strong></a>。</p>
<h4 id="Document-Types"><a href="#Document-Types" class="headerlink" title="Document Types"></a><code>Document Types</code></h4><p>文档类型，定义了应用程序所能识别的文档类型，并且还可以定义在系统中显示的该类型文档的自定义图标。</p>
<h4 id="Exported-UTIs"><a href="#Exported-UTIs" class="headerlink" title="Exported UTIs"></a><code>Exported UTIs</code></h4><p>导出的UTI，UTI Uniform Type Identifiers —— 同一类型标识符。</p>
<h4 id="Imported-UTIs"><a href="#Imported-UTIs" class="headerlink" title="Imported UTIs"></a><code>Imported UTIs</code></h4><p>导入的UTI</p>
<h4 id="URL-Types"><a href="#URL-Types" class="headerlink" title="URL Types"></a><code>URL Types</code></h4><p>URL类型，用来定义URL以便让应用程序理解应用间交换的数据结构。可用于：IOS唤醒其他程序，程序间相互调用。例如：在 URLTypes 中 URLSchemes 中注册 AAPP；在B程序中，openUrl:[NSURL urlWithString:@”AAPP:”]；注意”:”冒号,没有冒号是不能成唤醒另一个程序的。其次如果参数中有“&amp;”特殊字符穿，建议对参数进行 base64 转换。</p>
<h3 id="Build-Settings-2"><a href="#Build-Settings-2" class="headerlink" title="Build Settings"></a>Build Settings</h3><p>target 的 Build Settings 选项卡是最主要的一部分编译选项设置，配置界面如下图所示，完整的 Build Settings 共有将近40项配置内容。从配置界面上看，每一项的配置都有四列（如果使用pod，还会增加一列），可以看到，从左至右的顺序分别是：Resolved 列、带 Target 图标列、带 Project 图标列、iOS Default 列，每一列所代表的意义如下。</p>
<p><img src="/uploads/iOS项目Project和Target配置详解/3FBCE6D5-218B-44D9-9944-79D3D23D9980.png" alt=""></p>
<ul>
<li><strong>Resolved 列</strong>：<strong>最终确定的编译方式，无法自己设定</strong>。其结果是根据其右边三栏的选择结果以及优先级顺序来确定最后编译时采用的编译方式。在图的第二行选项卡中选择<code>combined</code>选项，可以直接地看到只有该栏的最后结果。</li>
<li><strong>带 Target 图标列</strong>：<strong>target 的 Build Settings 配置的编译选项，可自定义</strong>。其优先级最高，一旦进行设置，则最后的编译方式以该栏的结果为准。</li>
<li><strong>带 Project 图标列</strong>：<strong>project 的 Build Settings 配置的编译选项，可自定义</strong>，这一栏的结果与 project 中 build setting 选项卡中的结果是一致的，修改其中一个地方，另一处也会自动修改。其优先级介于 target 和 default 之间，当 target 没有设置编译选项，而该栏进行了设置时，则最后的编译方式以该栏为准。 </li>
<li><strong>iOS Default 列</strong>：<strong>在创建项目时系统自带的默认编译选项，无法修改</strong>。优先级最低，只有当其他两栏都没有设置选项时，最后的编译方式才会以该栏为准。</li>
</ul>
<p><strong>优先级顺序：带 Target 图标列 &gt;&gt; 带 Project 图标列 &gt;&gt; iOS Default 列</strong>。（如果安装pod，新产生的一列优先级介于带 Target 图标列和带 Project 图标列之间）</p>
<p><a href="http://www.360doc.com/content/14/1217/07/19175681_433531035.shtml" target="_blank" rel="external"><strong>Xcode 编译选项详解</strong></a>。</p>
<h3 id="Build-phases"><a href="#Build-phases" class="headerlink" title="Build phases"></a>Build phases</h3><p>Target 的 build phases 选项卡的的主要功能是配置编译器在不同编译阶段的参数，包括编译所需的资源文件（包括代码、配置以及各种资源文件），配置界面如下图所示，主要包括四方面的内容。</p>
<p><img src="/uploads/iOS项目Project和Target配置详解/C90783E8-1A9E-4C5E-8787-54753BFBE122.png" alt=""></p>
<h4 id="Target-Dependencies"><a href="#Target-Dependencies" class="headerlink" title="Target Dependencies"></a><code>Target Dependencies</code></h4><p>Target 对象依赖阶段：某些 target 可能依赖某个 target 输出的值，这里设置依赖。依赖于其他 target 的输出的时候，在编译时系统会自动先编译被依赖的 target，得到输出值，再编译当前 target。对象依赖阶段可以让 Xcode 知道必须在当前选择的对象编译之前先编译的其它依赖对象（比如应用扩展、插件等等）。如单元测试 target，依赖于 App target，所以必须等 App target 编译完成之后再进行编译。</p>
<h4 id="Compile-Sources"><a href="#Compile-Sources" class="headerlink" title="Compile Sources"></a><code>Compile Sources</code></h4><p>源文件阶段：是指将有哪些源代码被编译，可以通过对应的【+】【-】按钮进行添加或删除资源来控制编译的代码文件。并且可以通过修改此阶段的 Compiler Flags（编译器标识）来为每个单独文件设置其编译器标示，比如设置是否支持ARC。</p>
<h4 id="Link-Binary-With-Libraries"><a href="#Link-Binary-With-Libraries" class="headerlink" title="Link Binary With Libraries"></a><code>Link Binary With Libraries</code></h4><p>链接二进制库阶段：是指编译过程中会引用哪些库文件，我们同样可以通过【+】【-】按钮进行添加或删除编译所引用的库文件。</p>
<h4 id="Copy-Bundle-Resources"><a href="#Copy-Bundle-Resources" class="headerlink" title="Copy Bundle Resources"></a><code>Copy Bundle Resources</code></h4><p>拷贝 Bundle 资源阶段：是指生成的 product 的 .app 内将包含哪些资源文件，同样可以通过红框中的【+】【-】按钮进行添加或删除资源来控制编译的资源文件。该阶段定义了对象中的资源文件，包括应用程序、图标、storyboard、视频、模板等等。这些资源都会被复制到安装包的 Contents／Resources 文件夹下。</p>
<h3 id="Build-Rules"><a href="#Build-Rules" class="headerlink" title="Build Rules"></a>Build Rules</h3><p>Build rules 指定了不同文件类型该如何编译。一般来说，开发者并不需要修改这里面的内容。</p>
<p>如果需要对特定的文件类型添加处理方法，那么可以在此处添加一条新的规则。一条 build rule 指定了其应用于哪种文件类型，该文件类型是如何被处理的，以及输出内容被放置到何处。比方说，我们创建了一条预处理规则，该规则将Objective-C的实现文件当做输入，然后解析文件内部的注释内容，最后再输出一个.m文件，文件中包含了生成的代码。由于不能将 .m 文件既当做输入又当做输出，所以使用了.mal 后缀，定制的 build rule 如下所示：</p>
<p><img src="/uploads/iOS项目Project和Target配置详解/48118764_5-6911734.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS 开发之 UIResponder 详解]]></title>
      <url>http://liugangqiang.com/2017/09/20/iOS%20%E5%BC%80%E5%8F%91%E4%B9%8B%20UIResponder%20%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>在 iOS 中 UIResponder 类是专门用来响应用户的操作处理各种事件的，包括触摸事件(Touch Events)、运动事件(Motion Events)、远程控制事件(Remote Control Events)。</p>
<p>在UIKit中，UIApplication、UIView、UIViewController这几个类是直接继承自UIResponder,所以这些类都可以响应事件。因此 UIKit 中的视图、控件、视图控制器，以及我们自定义的视图及视图控制器都有响应事件的能力。这些对象通常被称为<code>响应对象</code>，或者是<code>响应者</code>。</p>
<p>本文将详细介绍一个 UIResponder 类提供的基本功能。</p>
<a id="more"></a>
<h2 id="管理响应链"><a href="#管理响应链" class="headerlink" title="管理响应链"></a>管理响应链</h2><p>UIResponder 提供了几个方法来管理响应链，包括让响应对象成为第一响应者、放弃第一响应者、检测是否是第一响应者以及传递事件到下一响应者的方法，我们分别来介绍一下。</p>
<h3 id="1-查找响应者链"><a href="#1-查找响应者链" class="headerlink" title="1. 查找响应者链"></a>1. 查找响应者链</h3><p>响应者链中负责事件传递的方法是<code>nextResponder</code>，声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (UIResponder *)nextResponder;</span><br></pre></td></tr></table></figure>
<p>UIResponder 类本身不保存或设置下一个响应者。由子类的实现重写来设置下一个响应者（这里说的是 UIView，UIViewController，UIApplication）。响应链是在构建视图层次结构时生成的。</p>
<p>关于 nextResponder 的值总结如下：</p>
<ol>
<li><code>UIView</code> 的 <code>nextResponder</code> 是直接管理它的 <code>UIViewController</code> (也就是 VC.view.nextResponder=VC ),如果当前<code>View</code>不是<code>ViewController</code>直接管理的<code>View</code>，则<code>nextResponder</code>是它的<code>superView</code>(view.nextResponder = view.superView)</li>
<li><code>UIViewController</code>的<code>nextResponder</code>是它直接管理的<code>View</code>的<code>superView</code>(VC.nextResponder = VC.view.superView)</li>
<li><code>UIWindow</code>的<code>nextResponder</code>是<code>UIApplication</code></li>
<li><code>UIApplication</code>的<code>nextResponder</code>是<code>UIApplicationDelegate</code>(官方文档说是nil)</li>
</ol>
<p>调用如下代码可以打印当前 UIResponder 的所有 nextResponder</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GGLogResponderChain</span><span class="params">(UIResponder *responder)</span> </span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"------------------The Responder Chain------------------"</span>);</span><br><span class="line">    NSMutableString *spaces = [NSMutableString stringWithCapacity:<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">while</span> (responder) &#123;</span><br><span class="line">        NSLog(@<span class="string">"%@%@"</span>, spaces, responder.<span class="keyword">class</span>);</span><br><span class="line">        responder = responder.nextResponder;</span><br><span class="line">        [spaces appendString:@<span class="string">"----"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果类似这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UILabel</span><br><span class="line">----UIView</span><br><span class="line">--------ViewController</span><br><span class="line">------------UIWindow</span><br><span class="line">----------------UIApplication</span><br><span class="line">--------------------AppDelegate</span><br></pre></td></tr></table></figure>
<p><img src="http://ww3.sinaimg.cn/mw690/6941baebgw1er8s01a7n8j213l0lhn1d.jpg" alt="img"></p>
<h3 id="2-设置与取消第一响应者"><a href="#2-设置与取消第一响应者" class="headerlink" title="2. 设置与取消第一响应者"></a>2. 设置与取消第一响应者</h3><p>一个响应对象可以成为第一响应者，也可以放弃第一响应者。为此，<code>UIResponder</code>提供了一系列方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判定对象是否是第一响应者</span></span><br><span class="line">- (BOOL)isFirstResponder;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断对象是否允许成为第一响应者 </span></span><br><span class="line">- (BOOL)canBecomeFirstResponder; </span><br><span class="line"><span class="comment">// 成为第一响应者 </span></span><br><span class="line">- (BOOL)becomeFirstResponder;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断对象是否允许放弃第一响应者</span></span><br><span class="line">- (BOOL)canResignFirstResponder; </span><br><span class="line"><span class="comment">// 放弃第一响应者 </span></span><br><span class="line">- (BOOL)resignFirstResponder;</span><br></pre></td></tr></table></figure>
<p>只有当视图是视图层次结构的一部分时才调用上面的方法才有效</p>
<h2 id="管理输入视图"><a href="#管理输入视图" class="headerlink" title="管理输入视图"></a>管理输入视图</h2><p>所谓的输入视图：是指当对象为第一响应者时，显示另外一个视图用来处理当前对象的信息输入。</p>
<p>如<code>UITextView</code>和<code>UITextField</code>两个对象，在其成为第一响应者是，会显示一个系统键盘，用来输入信息。这个系统键盘就是输入视图。输入视图有两种，一个是<code>inputView</code>，另一个是<code>inputAccessoryView</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两个属性提供一个视图(或视图控制器)用于替代为 UITextField 和 UITextView 弹出的系统键盘。我们可以在子类中将这两个属性重新定义为读写属性来设置这个属性。如果我们需要自己写一个键盘的，如为输入框定义一个用于输入身份证的键盘(只包含0-9和X)，则可以使用这两个属性来获取这个键盘。</span></span><br><span class="line">@property (nullable, nonatomic, readonly, strong) __<span class="function">kindof UIView *inputView <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">3</span>_2)</span></span>;</span><br><span class="line">@property (nullable, nonatomic, readonly, strong) <span class="function">UIInputViewController *inputViewController <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">8</span>_0)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置了InputAccessoryView，它会随着键盘一起出现并且会显示在键盘的顶端。InutAccessoryView默认为nil.</span></span><br><span class="line"><span class="comment">// 设置方法与前面相同，都是在子类中重新定义为可读写属性，以设置这个属性。</span></span><br><span class="line">@property (nullable, nonatomic, readonly, strong) __<span class="function">kindof UIView *inputAccessoryView <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">3</span>_2)</span></span>;</span><br><span class="line">@property (nullable, nonatomic, readonly, strong) <span class="function">UIInputViewController *inputAccessoryViewController <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">8</span>_0)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象是第一响应者时，调用这个方法时，视图会立即被替换，不会有动画之类的过渡。当前对象不是第一响应者，则该方法是无效的</span></span><br><span class="line">- (<span class="keyword">void</span>)reloadInputViews</span><br></pre></td></tr></table></figure>
<h2 id="管理文本输入模式"><a href="#管理文本输入模式" class="headerlink" title="管理文本输入模式"></a>管理文本输入模式</h2><p>文本输入模式标识当响应者激活时的语言及显示的键盘。<code>UIResponder</code>为此定义了一个属性来返回响应者对象的文本输入模式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, readonly, strong) UITextInputMode *textInputMode;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于响应者而言，系统通常显示一个基于用户语言设置的键盘。</li>
<li>我们可以重新定义这个属性，并让它返回一个不同的文本输入模式，以让我们的响应者使用一个特定的键盘。</li>
<li>用户在响应者被激活时仍然可以改变键盘，在切换到另一个响应者时，可以再恢复到指定的键盘。</li>
</ul>
<p>如果我们想让UIKit来跟踪这个响应者的文本输入模式，我们可以通过<code>textInputContextIdentifier</code>属性来设置一个标识，该属性的声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, readonly, strong) NSString *textInputContextIdentifier;</span><br></pre></td></tr></table></figure>
<p>该标识指明响应者应保留文本输入模式的信息。在跟踪模式下，任何对文本输入模式的修改都会记录下来，当响应者激活时再用于恢复处理。</p>
<p>为了从程序的user default中清理输入模式信息，UIResponder定义了一个类方法，其声明如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)clearTextInputContextIdentifier:(NSString *)identifier</span><br></pre></td></tr></table></figure>
<p>调用这个方法可以从程序的user default中移除与指定标识相关的所有文本输入模式。移除这些信息会让响应者重新使用默认的文本输入模式。</p>
<h2 id="响应触摸事件"><a href="#响应触摸事件" class="headerlink" title="响应触摸事件"></a>响应触摸事件</h2><p><code>UIResponder</code>提供了如下四个大家都非常熟悉的方法来响应触摸事件：<code>UIResponder</code>提供了如下四个大家都非常熟悉的方法来响应触摸事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手指按下的时候调用</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line"><span class="comment">// 手指移动的时候调用</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line"><span class="comment">// 手指抬起的时候调用</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line"><span class="comment">// 取消(非正常离开屏幕，意外中断事件)</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3D Touch相关方法，当前触摸对象触摸时力量改变所触发的事件,返回值是UITouchPropertyie</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)<span class="function">touches <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">9</span>_1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这四个方法默认都是什么都不做。不过，UIKit中<code>UIResponder</code>的子类，尤其是UIView，这几个方法的实现都会把消息传递到响应链上。因此，如果要不阻断响应链，我们的子类在重写时需要调用父类的相应方法；而不要将消息直接发送给下一响应者。</p>
<h2 id="响应移动事件"><a href="#响应移动事件" class="headerlink" title="响应移动事件"></a>响应移动事件</h2><p>与触摸事件类似，<code>UIResponder</code>也提供了几个方法来响应移动事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动事件开始</span></span><br><span class="line">- (<span class="keyword">void</span>)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event</span><br><span class="line"><span class="comment">// 移动事件结束</span></span><br><span class="line">- (<span class="keyword">void</span>)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event</span><br><span class="line"><span class="comment">// 取消移动事件</span></span><br><span class="line">- (<span class="keyword">void</span>)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event</span><br></pre></td></tr></table></figure>
<p>与触摸事件不同的是，运动事件只有开始与结束操作；它不会报告类似于晃动这样的事件。这几个方法的默认操作也是什么都不做。不过，UIKit中<code>UIResponder</code>的子类，尤其是UIView，这几个方法的实现都会把消息传递到响应链上。</p>
<h2 id="响应远程控制事件"><a href="#响应远程控制事件" class="headerlink" title="响应远程控制事件"></a>响应远程控制事件</h2><p>远程控制事件来源于一些外部的配件，如耳机等。</p>
<p>用户可以通过耳机来控制视频或音频的播放。接收响应者对象需要检查事件的子类型来确定命令（如播放，子类型为<code>UIEventSubtypeRemoteControlPlay</code>），然后进行相应处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure>
<p>我们可以在子类中实现该方法，来处理远程控制事件。为了控制是否能够分发远程控制事件，需要调用<code>UIApplication</code>的两个方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启远程控制事件的分发</span></span><br><span class="line">- (<span class="keyword">void</span>)beginReceivingRemoteControlEvents;</span><br><span class="line"><span class="comment">// 关闭远程控制事件的分发</span></span><br><span class="line">- (<span class="keyword">void</span>)endReceivingRemoteControlEvents;</span><br></pre></td></tr></table></figure>
<h2 id="获取Undo管理器"><a href="#获取Undo管理器" class="headerlink" title="获取Undo管理器"></a>获取Undo管理器</h2><p>默认地，每个应用的 window 都有一个 undo manager，每一个响应链条中的对象都可以管理一个自定义的 undo manager 来管理各自页面上本地操作的撤销和重做操作。<code>UITextField</code> 和 <code>UITextView</code> 用这个功能自动提供了文本编辑的撤销重做支持。当需要一个 undo manager 时，请求会沿着响应链传递，然后<code>UIWindow</code>对象会返回一个可用的实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nullable, nonatomic,readonly) NSUndoManager *undoManager</span><br></pre></td></tr></table></figure>
<h2 id="验证命令"><a href="#验证命令" class="headerlink" title="验证命令"></a>验证命令</h2><p>在我们的应用中，经常会处理各种菜单命令，如文本输入框的”复制”、”粘贴”等。<code>UIResponder</code>为此提供了两个方法来支持此类操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动或禁用指定的命令。这个方法会在 UIMenuController 的每一个 menuItem 生成的时候调用一次, 因此在方法体里就要根据 action 来判断是否需要显示在菜单里, 如果不需要, 则返回NO</span></span><br><span class="line">- (BOOL)canPerformAction:(SEL)action withSender:(nullable id)sender</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统一个 UIResponderStandardEditActions 的协议，可以重写 UIMenuItem 所对应的 action 修改系统默认的操作</span></span><br><span class="line"><span class="comment">// 剪切、拷贝、粘贴、选择、全选、删除事件</span></span><br><span class="line">- (<span class="keyword">void</span>)cut:(nullable id)<span class="function">sender <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">3</span>_0)</span></span>;</span><br><span class="line">- (<span class="keyword">void</span>)copy:(nullable id)<span class="function">sender <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">3</span>_0)</span></span>;</span><br><span class="line">- (<span class="keyword">void</span>)paste:(nullable id)<span class="function">sender <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">3</span>_0)</span></span>;</span><br><span class="line">- (<span class="keyword">void</span>)select:(nullable id)<span class="function">sender <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">3</span>_0)</span></span>;</span><br><span class="line">- (<span class="keyword">void</span>)selectAll:(nullable id)<span class="function">sender <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">3</span>_0)</span></span>;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="keyword">delete</span>:(nullable id)<span class="function">sender <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">3</span>_2)</span></span>;</span><br><span class="line"><span class="comment">// 从左到右写入字符串(居左)</span></span><br><span class="line">- (<span class="keyword">void</span>)makeTextWritingDirectionLeftToRight:(nullable id)<span class="function">sender <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">5</span>_0)</span></span>;</span><br><span class="line"><span class="comment">// 从右到左写入字符串(居右)</span></span><br><span class="line">- (<span class="keyword">void</span>)makeTextWritingDirectionRightToLeft:(nullable id)<span class="function">sender <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">5</span>_0)</span></span>;</span><br><span class="line"><span class="comment">// 切换字体为黑体(粗体)</span></span><br><span class="line">- (<span class="keyword">void</span>)toggleBoldface:(nullable id)<span class="function">sender <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">6</span>_0)</span></span>;</span><br><span class="line"><span class="comment">// 切换字体为斜体</span></span><br><span class="line">- (<span class="keyword">void</span>)toggleItalics:(nullable id)<span class="function">sender <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">6</span>_0)</span></span>;</span><br><span class="line"><span class="comment">// 给文字添加下划线</span></span><br><span class="line">- (<span class="keyword">void</span>)toggleUnderline:(nullable id)<span class="function">sender <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">6</span>_0)</span></span>;</span><br><span class="line"><span class="comment">// 增加字体大小</span></span><br><span class="line">- (<span class="keyword">void</span>)increaseSize:(nullable id)<span class="function">sender <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">7</span>_0)</span></span>;</span><br><span class="line"><span class="comment">// 减小字体大小</span></span><br><span class="line">- (<span class="keyword">void</span>)decreaseSize:(nullable id)<span class="function">sender <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">7</span>_0)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外还有几个系统不允许修改的 action</span></span><br><span class="line">_promptForReplace: <span class="comment">// Replace...替换</span></span><br><span class="line">_transliterateChinese: <span class="comment">// 简&lt;=&gt;繁</span></span><br><span class="line">_insertDrawing: <span class="comment">// 插入绘图</span></span><br><span class="line">_showTextStyleOptions: <span class="comment">// B/&lt;u&gt;U&lt;/u&gt;</span></span><br><span class="line">_lookup: <span class="comment">// 查询</span></span><br><span class="line">_define: <span class="comment">// Define </span></span><br><span class="line">_addShortcut: <span class="comment">// 添加...</span></span><br><span class="line">_accessibilitySpeak: <span class="comment">// Speak 朗读</span></span><br><span class="line">_accessibilitySpeakLanguageSelection: <span class="comment">// Speak... 朗读...</span></span><br><span class="line">_accessibilityPauseSpeaking: <span class="comment">// Pause 暂停</span></span><br><span class="line">_share: <span class="comment">// 共享...</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的实现是调用 canPerformAction:withSender: 方法来确定对象是否可以调用 action 操作，要么返回 self，要么传递到响应者链上。如果我们想要重写目标的选择方式，则应该重写这个方法</span></span><br><span class="line">- (id)targetForAction:(SEL)action withSender:(id)<span class="function">sender <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">7</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="访问快捷键命令"><a href="#访问快捷键命令" class="headerlink" title="访问快捷键命令"></a>访问快捷键命令</h2><p>我们的应用可以支持外部设备，包括外部键盘。在使用外部键盘时，使用快捷键可以大大提高我们的输入效率。因此从iOS7后，<code>UIResponder</code>类新增了一个只读属性<code>keyCommands</code>，来定义一个响应者支持的快捷键：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_OPTIONS</span><span class="params">(NSInteger, UIKeyModifierFlags)</span> </span>&#123;</span><br><span class="line">    UIKeyModifierAlphaShift     = <span class="number">1</span> &lt;&lt; <span class="number">16</span>,  <span class="comment">// This bit indicates CapsLock // Alpha+Shift 键</span></span><br><span class="line">    UIKeyModifierShift          = <span class="number">1</span> &lt;&lt; <span class="number">17</span>,	<span class="comment">// Shift 键</span></span><br><span class="line">    UIKeyModifierControl        = <span class="number">1</span> &lt;&lt; <span class="number">18</span>,	<span class="comment">// Control 键</span></span><br><span class="line">    UIKeyModifierAlternate      = <span class="number">1</span> &lt;&lt; <span class="number">19</span>,	<span class="comment">// Alt 键</span></span><br><span class="line">    UIKeyModifierCommand        = <span class="number">1</span> &lt;&lt; <span class="number">20</span>,	<span class="comment">// Command 键</span></span><br><span class="line">    UIKeyModifierNumericPad     = <span class="number">1</span> &lt;&lt; <span class="number">21</span>,	<span class="comment">// Num 键</span></span><br><span class="line">&#125; NS_ENUM_AVAILABLE_IOS(<span class="number">7</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">//按键命令类：</span></span><br><span class="line">@interface UIKeyCommand : NSObject &lt;NSCopying, NSSecureCoding&gt;</span><br><span class="line"></span><br><span class="line">- (instancetype)init NS_DESIGNATED_INITIALIZER;</span><br><span class="line">- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入字符串</span></span><br><span class="line">@property (nonatomic,readonly) NSString *input;</span><br><span class="line"><span class="comment">// 按键调节器</span></span><br><span class="line">@property (nonatomic,readonly) UIKeyModifierFlags modifierFlags;</span><br><span class="line"><span class="comment">// 按指定调节器键输入字符串并设置事件</span></span><br><span class="line">@property (nonatomic,copy) <span class="function">NSString *discoverabilityTitle <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">9</span>_0)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The action for UIKeyCommands should accept a single (id)sender, as do the UIResponderStandardEditActions above</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates an key command that will _not_ be discoverable in the UI.</span></span><br><span class="line">+ (UIKeyCommand *)keyCommandWithInput:(NSString *)input modifierFlags:(UIKeyModifierFlags)modifierFlags action:(SEL)action;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Key Commands with a discoverabilityTitle _will_ be discoverable in the UI.</span></span><br><span class="line">+ (UIKeyCommand *)keyCommandWithInput:(NSString *)input modifierFlags:(UIKeyModifierFlags)modifierFlags action:(SEL)action discoverabilityTitle:(NSString *)<span class="function">discoverabilityTitle <span class="title">NS_AVAILABLE_IOS</span><span class="params">(<span class="number">9</span>_0)</span></span>;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>一个支持硬件键盘命令的响应者对象可以重新定义这个方法并使用它来返回一个其所支持快捷键对象(UIKeyCommand)的数组（在UIResponder (UIResponderKeyCommands)分类中）。每一个快捷键命令表示识别的键盘序列及响应者的操作方法。</p>
<p>我们用这个方法返回的快捷键命令数组被用于整个响应链。当与快捷键命令对象匹配的快捷键被按下时，UIKit会沿着响应链查找实现了响应行为方法的对象。它调用找到的第一个对象的方法并停止事件的处理。</p>
<h2 id="支持User-Activities"><a href="#支持User-Activities" class="headerlink" title="支持User Activities"></a>支持User Activities</h2><p>从iOS 8起，苹果提供了 Handoff 功能。使用这一功能，我们可以在一部 iOS 设备的某个应用上开始做一件事，然后在另一台iOS设备上继续做这件事。</p>
<p>Handoff的基本思想是用户在一个应用里所做的任何操作都可以看作是一个Activity，一个Activity可以和一个特定iCloud用户的多台设备关联起来。在编写一个支持Handoff的应用时，会有以下三个交互事件：</p>
<ol>
<li>为将在另一台设备上继续做的事创建一个新的 User Activity； </li>
<li>当需要时，用新的数据更新已有的 User Activity； </li>
<li>把一个 User Activity 传递到另一台设备上。</li>
</ol>
<p>为了支持这些交互事件，在iOS 8后，UIResponder 类新增了几个方法。在 UIResponder 中，已经为我们提供了一个userActivity 属性，它是一个NSUserActivity对象。因此我们在 UIResponder 的子类中不需要再去声明一个 userActivity 属性，直接使用它就行。其声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, retain) NSUserActivity *userActivity</span><br></pre></td></tr></table></figure>
<p>由UIKit管理的 User Activities 会在适当的时间自动保存。一般情况下，我们可以重写 UIResponder 类的<code>updateUserActivityState:</code>方法来延迟添加表示 User Activity 的状态数据。</p>
<p>当我们不再需要一个 User Activity 时，我们可以设置 <code>userActivity</code> 属性为 nil。任何由 UIKit 管理的<code>NSUserActivity</code>对象，如果它没有相关的响应者，则会自动失效。<br>另外，多个响应者可以共享一个<code>NSUserActivity</code>实例。<br>上面提到的<code>updateUserActivityState:</code>是用于更新给定的User Activity的状态。其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateUserActivityState:(NSUserActivity *)activity</span><br></pre></td></tr></table></figure></p>
<p>子类可以重写这个方法来按照我们的需要更新给定的 User Activity。我们需要使用<code>NSUserActivity</code>对象的<code>addUserInfoEntriesFromDictionary:</code>方法来添加表示用户Activity的状态。<br>在我们修改了User Activity的状态后，如果想将其恢复到某个状态，则可以使用以下方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)restoreUserActivityState:(NSUserActivity *)activity</span><br></pre></td></tr></table></figure></p>
<p>子类可以重写这个方法来使用给定 User Activity 的恢复响应者的状态。系统会在接收到数据时，将数据传递给<code>application:continueUserActivity:restorationHandler:</code>以做处理。我们重写时应该使用存储在 user activity 的<code>userInfo</code>字典中的状态数据来恢复对象。当然，我们也可以直接调用这个方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS分类(category)和类扩展(extension)]]></title>
      <url>http://liugangqiang.com/2017/08/13/iOS%E5%88%86%E7%B1%BB(category)%E5%92%8C%E7%B1%BB%E6%89%A9%E5%B1%95(extension)/</url>
      <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>无论一个类设计的多么完美，在需求的演进当中，总会碰到一些无法预测的情况。那么怎么扩展已有的类？一般而言，有继承和组合两种选择。在 Objective-C 2.0 中，又提供了 category 这个语言特性，可以动态地为已有类添加新行为。本文将对 category 和 extension 进行介绍。</p>
<a id="more"></a>
<h2 id="分类-category"><a href="#分类-category" class="headerlink" title="分类(category)"></a>分类(category)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>category 是 Objective-C 2.0 之后添加的语言特性，category 的主要作用是为已经存在的类添加方法。apple 还推荐了category 的另外两个使用场景</p>
<ol>
<li>可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处：<ul>
<li>可以减少单个文件的体积</li>
<li>可以把不同的功能组织到不同的 category 里 </li>
<li>可以由多个开发者共同完成一个类</li>
<li>可以按需加载想要的 category 等等</li>
</ul>
</li>
<li>声明私有方法</li>
</ol>
<p>不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：</p>
<ol>
<li>模拟多继承</li>
<li>把 framework 的私有方法公开</li>
</ol>
<h3 id="category-的结构"><a href="#category-的结构" class="headerlink" title="category 的结构"></a>category 的结构</h3><p>所有的 OC 类和对象，在 runtime 层都是用 struct 表示的，category 也不例外。在runtime层，category用结构体category_t</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">category_t</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;							<span class="comment">// 分类名字</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls;								<span class="comment">// 所属类</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *instanceMethods;		<span class="comment">// category 中所有给类添加的实例方法的列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *classMethods;			<span class="comment">// category 中所有添加的类方法的列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">protocol_list_t</span> *protocols;			<span class="comment">// category 实现的所有协议的列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">property_list_t</span> *instanceProperties; <span class="comment">// category 中添加的所有属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从 category 的定义也可以看出 category 的可以添加实例方法，类方法，实现协议，添加属性；但是无法添加实例变量。</p>
<h3 id="category-的编译解析"><a href="#category-的编译解析" class="headerlink" title="category 的编译解析"></a>category 的编译解析</h3><p>自定义一个类，GGShop.h :</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">// 自定义的类</span><br><span class="line">@interface GGShop : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">- (void)doSomething;</span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">// GGShop 的分类 Add</span><br><span class="line">@interface GGShop (Add)&lt;NSCopying&gt;</span><br><span class="line">@property (nonatomic, copy) NSString *age;</span><br><span class="line">- (void)doSomething;</span><br><span class="line">+ (void)otherSomthing;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>GGShop.m:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#import "GGShop.h"</span><br><span class="line"></span><br><span class="line">@implementation GGShop</span><br><span class="line">- (void)doSomething &#123;</span><br><span class="line">    NSLog(@"++++++");</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation GGShop (Add)</span><br><span class="line">- (void)doSomething &#123;</span><br><span class="line">    NSLog(@"------");</span><br><span class="line">&#125;</span><br><span class="line">+ (void)otherSomthing &#123;</span><br><span class="line">    NSLog(@"======");</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>使用 clang 的命令去看看 category 到底会变成什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc GGShop.m</span><br></pre></td></tr></table></figure>
<p>执行命令后，<code>GGShop.m</code> 被编译成一个 <code>GGShop.cpp</code>文件，大约 3.5M，代码将近10万行，搜索在文件得最后位置找到分类的代码片段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类实现的实例方法列表，只是在 .h 中声明了但没有实现的方法不会出现在这里</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="comment">/*_method_list_t*/</span> &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">	<span class="keyword">struct</span> _objc_method method_list[<span class="number">1</span>];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_GGShop_$_Add __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	&#123;&#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"doSomething"</span>, <span class="string">"v16@0:8"</span>, (<span class="keyword">void</span> *)_I_GGShop_Add_doSomething&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类实现的类方法列表，同样只声明了的不会编译出现</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="comment">/*_method_list_t*/</span> &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">	<span class="keyword">struct</span> _objc_method method_list[<span class="number">1</span>];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_CLASS_METHODS_GGShop_$_Add __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	&#123;&#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"otherSomthing"</span>, <span class="string">"v16@0:8"</span>, (<span class="keyword">void</span> *)_C_GGShop_Add_otherSomthing&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类遵守的协议列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="comment">/*_protocol_list_t*/</span> &#123;</span><br><span class="line">	<span class="keyword">long</span> protocol_count;  <span class="comment">// Note, this is 32/64 bit</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="keyword">_protocol_t</span> *super_protocols[<span class="number">1</span>];</span><br><span class="line">&#125; _OBJC_CATEGORY_PROTOCOLS_$_GGShop_$_Add __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	&amp;_OBJC_PROTOCOL_NSCopying</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类的属性列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="comment">/*_prop_list_t*/</span> &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line">	<span class="keyword">struct</span> <span class="keyword">_prop_t</span> prop_list[<span class="number">1</span>];</span><br><span class="line">&#125; _OBJC_$_PROP_LIST_GGShop_$_Add __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(<span class="keyword">_prop_t</span>),</span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	&#123;&#123;<span class="string">"age"</span>,<span class="string">"T@\"NSString\",C,N"</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllexport) <span class="keyword">struct</span> <span class="keyword">_class_t</span> OBJC_CLASS_$_GGShop;</span><br><span class="line"><span class="comment">// 分类的结构体</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="keyword">_category_t</span> _OBJC_$_CATEGORY_GGShop_$_Add __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = </span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"GGShop"</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_GGShop,</span></span><br><span class="line">	(<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_GGShop_$_Add,</span><br><span class="line">	(<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_GGShop_$_Add,</span><br><span class="line">	(<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">_protocol_list_t</span> *)&amp;_OBJC_CATEGORY_PROTOCOLS_$_GGShop_$_Add,</span><br><span class="line">	(<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_GGShop_$_Add,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> OBJC_CATEGORY_SETUP_$_GGShop_$_Add(<span class="keyword">void</span> ) &#123;</span><br><span class="line">	_OBJC_$_CATEGORY_GGShop_$_Add.cls = &amp;OBJC_CLASS_$_GGShop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="keyword">_category_t</span> *L_OBJC_LABEL_CATEGORY_$ [<span class="number">1</span>] __attribute__((used, section (<span class="string">"__DATA, __objc_catlist,regular,no_dead_strip"</span>)))= &#123;</span><br><span class="line">	&amp;_OBJC_$_CATEGORY_GGShop_$_Add,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，编译器生成了实例方法，类方法，属性，协议列表。它们的命名遵循</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公共前缀 + 类名 + 分类名</span></span><br><span class="line">_OBJC_$_CATEGORY_INSTANCE_METHODS_	GGShop_$_	Add,</span><br><span class="line">_OBJC_$_CATEGORY_CLASS_METHODS_		GGShop_$_	Add,</span><br><span class="line">_OBJC_CATEGORY_PROTOCOLS_$_			GGShop_$_	Add,</span><br><span class="line">_OBJC_$_PROP_LIST_					GGShop_$_	Add,</span><br></pre></td></tr></table></figure>
<ul>
<li>category 的名字（例如Add）用来给各种列表以及后面的 category 结构体本身命名，而且有 static 来修饰，所以在同一个编译单元里我们的 category 名不能重复，否则会出现编译错误。</li>
<li>编译器生成了category 本身 <code>_OBJC_$_CATEGORY_GGShop_$_Add</code>，并用前面生成的列表来初始化 category 本身。</li>
<li>最后，编译器在DATA段下的 objc_catlist section 里保存了一个大小为1的 category_t 的数组<code>L_OBJC_LABEL_CATEGORY_$</code>（如果有多个category，会生成对应长度的数组），用于运行期category的加载</li>
</ul>
<h3 id="category-的加载"><a href="#category-的加载" class="headerlink" title="category 的加载"></a>category 的加载</h3><p>Objective-C 的运行是依赖 OC 的<code>runtime</code>的，而 OC 的<code>runtime</code>和其他系统库一样，是 OS X 和 iOS 通过<a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html" target="_blank" rel="external"><code>dyld</code></a> 动态加载的。</p>
<p>对于 OC 运行时，入口方法如下（在objc-os.mm文件中）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register for unmap first, in case some +load unmaps something</span></span><br><span class="line">    _dyld_register_func_for_remove_image(&amp;unmap_image);</span><br><span class="line">    dyld_register_image_state_change_handler(dyld_image_state_bound,<span class="number">1</span><span class="comment">/*batch*/</span>, &amp;map_images);</span><br><span class="line">    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, <span class="number">0</span><span class="comment">/*not batch*/</span>, &amp;load_images);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// category 被附加到类上面是在 map_images 的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images 最终会调用 objc-runtime-new.mm 里面的 _read_images 方法，而在 _read_images 方法的结尾，有以下的代码片段：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Discover categories. </span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">// catlist 就是上节中讲到的编译器准备的 category_t 数组</span></span><br><span class="line">    <span class="keyword">category_t</span> **catlist = _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">        <span class="comment">// 获取 category_t 的类</span></span><br><span class="line">        <span class="keyword">class_t</span> *cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">            <span class="comment">// 类丢失，可能是弱连接的原因</span></span><br><span class="line">            <span class="comment">// Category's target class is missing (probably weak-linked).</span></span><br><span class="line">            <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">            catlist[i] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></span><br><span class="line">                             <span class="string">"missing weak-linked target class"</span>,</span><br><span class="line">                             cat-&gt;name, cat);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process this category. 处理分类</span></span><br><span class="line">        <span class="comment">// First, register the category with its target class. 首先，用目标类注册一个分类</span></span><br><span class="line">        <span class="comment">// Then, rebuild the class's method lists (etc) if the class is realized. 然后，如果类被实现了，重建它的方法列表</span></span><br><span class="line">        BOOL classExists = NO;</span><br><span class="line">        <span class="comment">// 把 category 的实例方法、协议以及属性添加到类上</span></span><br><span class="line">        <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols </span><br><span class="line">            ||  cat-&gt;instanceProperties)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 类和 category 做一个关联映射</span></span><br><span class="line">            addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">            <span class="keyword">if</span> (isRealized(cls)) &#123;</span><br><span class="line">                <span class="comment">// 这个方法实现添加</span></span><br><span class="line">                remethodizeClass(cls);</span><br><span class="line">                classExists = YES;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"CLASS: found category -%s(%s) %s"</span>,</span><br><span class="line">                             getName(cls), cat-&gt;name,</span><br><span class="line">                             classExists ? <span class="string">"on existing class"</span> : <span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把 category 的类方法和协议添加到类的 metaclass 上</span></span><br><span class="line">        <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols </span><br><span class="line">            <span class="comment">/* ||  cat-&gt;classProperties */</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            addUnattachedCategoryForClass(cat, cls-&gt;isa, hi);</span><br><span class="line">            <span class="keyword">if</span> (isRealized(cls-&gt;isa)) &#123;</span><br><span class="line">                remethodizeClass(cls-&gt;isa);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"CLASS: found category +%s(%s)"</span>,</span><br><span class="line">                             getName(cls), cat-&gt;name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看 <code>remethodizeClass</code>的具体实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remethodizeClass</span><span class="params">(<span class="keyword">class_t</span> *cls)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    BOOL isMeta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class="line"></span><br><span class="line">    isMeta = isMetaClass(cls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls))) &#123;</span><br><span class="line">        chained_property_list *newproperties;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">protocol_list_t</span> **newprotos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: attaching categories to class '%s' %s"</span>,</span><br><span class="line">                         getName(cls), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update methods, properties, protocols</span></span><br><span class="line">		<span class="comment">// 添加所有分类的方法</span></span><br><span class="line">        BOOL vtableAffected = NO;</span><br><span class="line">        attachCategoryMethods(cls, cats, &amp;vtableAffected);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组建属性列表</span></span><br><span class="line">        newproperties = buildPropertyList(<span class="literal">NULL</span>, cats, isMeta);</span><br><span class="line">        <span class="keyword">if</span> (newproperties) &#123;</span><br><span class="line">            newproperties-&gt;next = cls-&gt;data()-&gt;properties;</span><br><span class="line">            cls-&gt;data()-&gt;properties = newproperties;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 组建协议列表</span></span><br><span class="line">        newprotos = buildProtocolList(cats, <span class="literal">NULL</span>, cls-&gt;data()-&gt;protocols);</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;data()-&gt;protocols  &amp;&amp;  cls-&gt;data()-&gt;protocols != newprotos) &#123;</span><br><span class="line">            _free_internal(cls-&gt;data()-&gt;protocols);</span><br><span class="line">        &#125;</span><br><span class="line">        cls-&gt;data()-&gt;protocols = newprotos;</span><br><span class="line"></span><br><span class="line">        _free_internal(cats);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update method caches and vtables</span></span><br><span class="line">        flushCaches(cls);</span><br><span class="line">        <span class="keyword">if</span> (vtableAffected) flushVtables(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 而对于添加类的实例方法而言，又会去调用 attachCategoryMethods 这个方法，我们去看下attachCategoryMethods：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attachCategoryMethods</span><span class="params">(<span class="keyword">class_t</span> *cls, category_list *cats,</span><br><span class="line">                      BOOL *inoutVtablesAffected)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    BOOL isMeta = isMetaClass(cls);</span><br><span class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **) _malloc_internal(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">    BOOL fromBundle = NO;</span><br><span class="line">    <span class="comment">// 将所有分类的方法列表组装成一个大的列表</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = cat_method_list(cats-&gt;<span class="built_in">list</span>[i].cat, isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= cats-&gt;<span class="built_in">list</span>[i].fromBundle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 attachMethodLists 添加方法</span></span><br><span class="line">    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);</span><br><span class="line"></span><br><span class="line">    _free_internal(mlists);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// attachMethodLists 的部分代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> m = <span class="number">0</span>; (scanForCustomRR || scanForCustomAWZ)  &amp;&amp;  m &lt; mlist-&gt;count; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        SEL sel = method_list_nth(mlist, m)-&gt;name;</span><br><span class="line">        <span class="keyword">if</span> (scanForCustomRR  &amp;&amp;  isRRSelector(sel)) &#123;</span><br><span class="line">            cls-&gt;setHasCustomRR();</span><br><span class="line">            scanForCustomRR = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scanForCustomAWZ  &amp;&amp;  isAWZSelector(sel)) &#123;</span><br><span class="line">            cls-&gt;setHasCustomAWZ();</span><br><span class="line">            scanForCustomAWZ = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill method list array</span></span><br><span class="line">    newLists[newCount++] = mlist;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="comment">// Copy old methods to the method list array</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; oldCount; i++) &#123;</span><br><span class="line">        newLists[newCount++] = oldLists[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>category 的方法没有“完全替换掉”原来类已经有的方法，也就是说如果 category 和原来类都有 methodA，那么category 附加完成之后，类的方法列表里会有两个 methodA</li>
<li>category 的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category 的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。</li>
<li>如果有多个 category 都重新实现同一个方法，后加载的 category 的方法会加到其他同名方法的前面</li>
</ol>
<h3 id="category-和方法覆盖"><a href="#category-和方法覆盖" class="headerlink" title="category 和方法覆盖"></a>category 和方法覆盖</h3><p>怎么调用到原来类中被category覆盖掉的方法？ 对于这个问题，我们已经知道 category 其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Class className = [GGShop <span class="keyword">class</span>];</span><br><span class="line">GGShop *shop = [[GGShop alloc] init];</span><br><span class="line"></span><br><span class="line">NSLog(@<span class="string">"%@"</span>, shop);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (className) &#123;</span><br><span class="line">    <span class="comment">// 获取类的方法列表</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> methodCount;</span><br><span class="line">    Method *methodList = class_copyMethodList(className, &amp;methodCount);</span><br><span class="line">    </span><br><span class="line">    IMP methodIMP = <span class="literal">NULL</span>;</span><br><span class="line">	SEL methodSEL = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 遍历方法列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodCount; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        NSString *methodString = NSStringFromSelector(method_getName(method));</span><br><span class="line">        NSLog(@<span class="string">"------%@"</span>, methodString);</span><br><span class="line">        <span class="comment">// 寻找对应方法</span></span><br><span class="line">        <span class="keyword">if</span> ([@<span class="string">"doSomething"</span> isEqualToString:methodString]) &#123;</span><br><span class="line">            <span class="comment">// 获取找到的对应方法的 IMP 和 SEL </span></span><br><span class="line">            methodIMP = method_getImplementation(method);</span><br><span class="line">            methodSEL = method_getName(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接调用 IMP</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(* Func)</span><span class="params">(id, SEL)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (methodIMP != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Func f = (Func)methodIMP;</span><br><span class="line">        f(shop, methodSEL);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="category-和-load-方法"><a href="#category-和-load-方法" class="headerlink" title="category 和 +load 方法"></a>category 和 +load 方法</h3><p>类在加载时，会调用 +load 方法，如果分类中有 +load 方法，会怎样调用</p>
<p><img src="/uploads/4E4D7A42-98C8-4AB6-AE76-AFCF269A12EE.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    NSLog(@<span class="string">"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类和分类中分别重写 +load 方法。</p>
<p>在Xcode中点击Edit Scheme -&gt; Run -&gt; Arguments -&gt; Environment Variables，添加如下两个环境变量，设置 Value 为YES（可以在执行load方法以及加载 category 的时候打印 log 信息，更多的环境变量选项可参见objc-private.h）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OBJC_PRINT_LOAD_METHODS</span></span><br><span class="line"><span class="comment">// OBJC_PRINT_REPLACED_METHODS</span></span><br></pre></td></tr></table></figure>
<p> 按照 原类，Category1，Category2 的顺序加载类，运行输出结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">REPLACED: -[GGShop doSomething]  by category Category1 </span><br><span class="line">REPLACED: -[GGShop doSomething]  by category Category2</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">+[GGShop load]</span><br><span class="line">+[GGShop(Category1) load]</span><br><span class="line">+[GGShop(Category2) load]</span><br></pre></td></tr></table></figure>
<p>由打印结果可以看出：</p>
<ul>
<li>附加 Category 方法到类的工作会先于  +load 方法的执行</li>
<li>+load 方法会先后分被执行，顺序为首先执行原类的，然后按照 Category 文件加载的顺序先后执行。</li>
<li>在 +load 方法中不要调用父类的 +load 方法，因为父类在加载时会自动调用它的这个方法。</li>
<li>与其他运行时才调用的方法不同，+load 方法在 APP 启动时，可执行文件加载到内存时便调用了。其他运行时的方法，最后加载的会加到其他同名方法前边，调用时只执行这一个。而 +load 方法 会按照 文件加载的顺序先后分别执行。</li>
</ul>
<h3 id="category-和关联对象"><a href="#category-和关联对象" class="headerlink" title="category 和关联对象"></a>category 和关联对象</h3><p>在 category 里面是无法为类添加实例变量，但是可以通过 Runtime 的方法给类添加关联的值</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// .h</span><br><span class="line">#import "GGShop.h"</span><br><span class="line"></span><br><span class="line">@interface GGShop (Category1)</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .m</span><br><span class="line">#import "GGShop+Category1.h"</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation GGShop (Category1)</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    objc_setAssociatedObject(self, @"name", name, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    NSString *name = objc_getAssociatedObject(self, @"name");</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>但是关联对象又是存在什么地方呢？ 如何存储？ 对象销毁时候如何处理关联对象呢？</p>
<p> 在 runtime 的源码中，objc-references.mm 文件中有个方法 _object_set_associative_reference：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">    // retain the new value (if any) outside the lock.</span><br><span class="line">    ObjcAssociation old_association(0, nil);</span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        if (new_value) &#123;</span><br><span class="line">            // break any existing association.</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i != associations.end()) &#123;</span><br><span class="line">                // secondary table exists</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // create the new association (first time).</span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                _class_setInstancesHaveAssociatedObjects(_object_getClass(object));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // setting the association to nil breaks the association.</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // release the old value (outside of the lock).</span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AssociationsManager</span><br><span class="line">class AssociationsManager &#123;</span><br><span class="line">    static OSSpinLock _lock;</span><br><span class="line">    static AssociationsHashMap *_map;               // associative references:  object pointer -&gt; PtrPtrHashMap.</span><br><span class="line">public:</span><br><span class="line">    AssociationsManager()   &#123; OSSpinLockLock(&amp;_lock); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; OSSpinLockUnlock(&amp;_lock); &#125;</span><br><span class="line"></span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        if (_map == NULL)</span><br><span class="line">            _map = new AssociationsHashMap();</span><br><span class="line">        return *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到所有的关联对象都由<code>AssociationsManager</code>管理。</li>
<li><code>AssociationsManager</code>里面是由一个静态<code>AssociationsHashMap</code>来存储所有的关联对象的。</li>
<li>这相当于把所有对象的关联对象都存在一个全局 map 里面。而 map 的 key 是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个 map 的 value 又是另外一个<code>AssociationsHashMap</code>，里面保存了关联对象的kv对。</li>
</ul>
<p>而在对象的销毁逻辑里面，见objc-runtime-new.mm:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        Class isa_gen = _object_getClass(obj);</span><br><span class="line">        <span class="keyword">class_t</span> *isa = newcls(isa_gen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = hasCxxStructors(isa);</span><br><span class="line">        <span class="keyword">bool</span> assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!UseGC) objc_clear_deallocating(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>runtime 的销毁对象函数<code>objc_destructInstance</code>里面会判断这个对象有没有关联对象，如果有，会调用<code>_object_remove_assocations</code>做关联对象的清理工作。</p>
<h2 id="类扩展-extension"><a href="#类扩展-extension" class="headerlink" title="类扩展(extension)"></a>类扩展(extension)</h2><p>extension 被开发者称之为扩展、延展、匿名分类。extension 看起来很像一个匿名的category，但是 extension 和category 几乎完全是两个东西。和 category 不同的是 extension 不但可以声明方法，还可以声明属性、成员变量。extension 一般用于声明私有方法，私有属性，私有成员变量。</p>
<p>category是拥有.h文件和.m文件的东西。但是extension不然。extension只存在于一个.h文件中，或者extension只能寄生于一个类的.m文件中。比如，viewController.m文件中通常寄生这么个东西，其实这就是一个extension：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>当然我们也可以创建一个单独的extension文件，但是，extension 常用的形式并不是以一个单独的.h文件存在，而是寄生在类的.m文件中。</p>
<h2 id="category-和-extension-对比"><a href="#category-和-extension-对比" class="headerlink" title="category 和 extension 对比"></a>category 和 extension 对比</h2><p>extension 看起来像匿名的 category，但是 extension 和有名字的 category 几乎完全是两个东西。</p>
<ul>
<li>extension 在<strong>编译期决议</strong>，它就是类的一部分，在编译期和头文件里的<code>@interface</code>以及实现文件里的<code>@implement</code>一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension 一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加 extension，所以你无法为系统的类比如<code>NSString</code>添加 extension。</li>
<li>但是 category 则完全不一样，它是在<strong>运行期决议</strong>的。</li>
<li>extension 可以添加实例变量，而 category 是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</li>
<li>extension 和 category 都可以添加属性，但是 category 的属性不能生成成员变量和 getter、setter方法的实现</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git的使用简介]]></title>
      <url>http://liugangqiang.com/2017/05/25/Git%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Git 是目前世界上最先进的分布式版本控制系统。对应的是以SVN为代表的集中式控制系统。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">集中式（SVN）</th>
<th style="text-align:center">分布式（Git）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">是否有中央服务器</td>
<td style="text-align:center">有。开发人员需要从中央服务器获得最新版本的项目然后在本地开发，开发完推送给中央服务器。因此脱离服务器开发者是几乎无法工作的</td>
<td style="text-align:center">没有中央服务器，开发人员本地都有 Local Repository</td>
</tr>
<tr>
<td style="text-align:center">网络依赖</td>
<td style="text-align:center">必须要联网才能工作，而且对网络的依赖性较强，如果推送的文件比较大而且网络状况欠佳，则提交文件的速度会受到很大的限制。</td>
<td style="text-align:center">分布式在没有网络的情况下也可以执行commit、查看版本提交记录、以及分支操作，在有网络的情况下执行 push 到 Remote Repository。</td>
</tr>
<tr>
<td style="text-align:center">文件存储格式</td>
<td style="text-align:center">按照原始文件存储，体积较大</td>
<td style="text-align:center">按照元数据方式存储，体积很小</td>
</tr>
<tr>
<td style="text-align:center">是否有版本号</td>
<td style="text-align:center">有</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center">分支操作的影响</td>
<td style="text-align:center">创建新的分支则所有的人都会拥有和你一样的分支</td>
<td style="text-align:center">分支操作不会影响其他开发人员</td>
</tr>
<tr>
<td style="text-align:center">提交</td>
<td style="text-align:center">提交的文件会直接记录到中央版本库</td>
<td style="text-align:center">提交是本地操作，需要执行push操作才会到主要版本库</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 检查电脑是否安装 git (Mac OS)</span><br><span class="line">$ git</span><br><span class="line">// 以下信息提示未安装</span><br><span class="line">The program 'git' is currently not installed. You can install it by typing:</span><br><span class="line">sudo apt-get install git</span><br><span class="line">// 如果显示以下信息，表示git已经安装过，可以直接使用</span><br><span class="line">usage: git [--version] [--help] [-C &lt;path&gt;] [-c name=value]</span><br><span class="line">           [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]</span><br><span class="line">           [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]</span><br><span class="line">           [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;]</span><br><span class="line">           &lt;command&gt; [&lt;args&gt;]</span><br><span class="line">           ...</span><br></pre></td></tr></table></figure>
<p>使用Mac做开发，有两种安装Git的方法。</p>
<p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/" target="_blank" rel="external">http://brew.sh/</a>。</p>
<p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Source Control”，选择安装。</p>
<h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><p>版本库又名仓库，英文名<strong>repository</strong>，可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先选择一个合适的文件夹(目录)</span></span><br><span class="line">$ cd /Users/<span class="keyword">new</span>/LearnGit</span><br><span class="line"><span class="comment">// 通过 git init 命令把这个目录变成Git可以管理的仓库</span></span><br><span class="line">$ git init</span><br><span class="line"><span class="comment">// 下边信息表示版本库创建成功，第一行是创建一个空的库，第二行是已有的版本库重新初始化</span></span><br><span class="line">Initialized empty Git repository in /Users/<span class="keyword">new</span>/LearnGit/.git/  </span><br><span class="line">Reinitialized existing Git repository in /Users/<span class="keyword">new</span>/LearnGit/.git/</span><br></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">// 把修改的文件提交到仓库暂存区，可反复多次使用，添加多个文件</span><br><span class="line">$ git add &lt;fileName&gt;</span><br><span class="line">// 把文件提交到仓库</span><br><span class="line">$ git commit -m "这些写提交描述"</span><br><span class="line">// 查看仓库当前的状态</span><br><span class="line">$ git status</span><br><span class="line">// 对比修改</span><br><span class="line">$ git diff &lt;fileName&gt; </span><br><span class="line"></span><br><span class="line">// 查看版本控制系统历史记录</span><br><span class="line">$ git log</span><br><span class="line">$ git log --pretty=oneline</span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">// 查看每次命令记录</span><br><span class="line">$ git reflog</span><br><span class="line"></span><br><span class="line">// 版本回退</span><br><span class="line">$ git reset --hard HEAD^ 	// 回退到上个版本</span><br><span class="line">$ git reset --hard 1094a	// 会退到指定版本</span><br><span class="line">// 丢弃工作区的修改, 让这个文件回到最近一次git commit或git add时的状态</span><br><span class="line">$ git checkout -- &lt;fileName&gt; </span><br><span class="line">// 删除文件</span><br><span class="line">$ git rm &lt;fileName&gt;</span><br><span class="line"></span><br><span class="line">// 创建SSH Key (在用户主目录下，看看有没有.ssh（隐藏文件，使用 com + shift + . 显示）目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果没有则需要创建)</span><br><span class="line">$ ssh-keygen -t rsa -C "自己的邮件地址"</span><br><span class="line"></span><br><span class="line">// 关联远程库，远程库的名字默认是 origin</span><br><span class="line">$ git remote add origin git@server-name:path/repo-name.git</span><br><span class="line">// 把本地库的所有内容推送到远程库(把当前分支master推送到远程，第一次推送master分支时，加上了-u参数,Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来)</span><br><span class="line">$ git push -u origin master</span><br><span class="line">$ git push origin master</span><br><span class="line">// 当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</span><br><span class="line">The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br><span class="line">// Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了。警告只会出现一次，后面的操作就不会有任何警告了</span><br><span class="line">Warning: Permanently added 'github.com' (RSA) to the list of known hosts.</span><br><span class="line">    </span><br><span class="line">// 从远程库克隆一个本地库</span><br><span class="line">$ git clone git@server-name:path/repo-name.git</span><br><span class="line">// 例如 $ git clone git@github.com:michaelliao/gitskills.git</span><br><span class="line">// 还可以使用</span><br><span class="line">$ git clone https://github.com/michaelliao/gitskills.git</span><br><span class="line"></span><br><span class="line">// 查看远程库的信息</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">// 显示更详细的信息</span><br><span class="line">$ git remote -v</span><br><span class="line">// 显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br><span class="line">// 推送分支。推送时，指定本地分支，Git就会把该分支推送到远程库对应的远程分支上：</span><br><span class="line">$ git push origin master</span><br><span class="line">$ git push origin dev  </span><br><span class="line">// 如果推送失败 先抓取远程的新提交</span><br><span class="line">$ git pull</span><br><span class="line">// 在本地创建和远程分支对应的分支，本地和远程分支的名称最好一致</span><br><span class="line">$ git checkout -b branch-name origin/branch-name</span><br><span class="line">// 建立本地分支和远程分支的关联</span><br><span class="line">$ git branch --set-upstream branch-name origin/branch-name</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</span><br><span class="line">master 分支是主分支，因此要时刻与远程同步；</span><br><span class="line">dev    分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</span><br><span class="line">bug    分支只用于在本地修复bug，就没必要推到远程了，除非有特殊要求，如老板要看每周到底修复了几个bug；</span><br><span class="line">feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 分支管理</span><br><span class="line">// 创建分支</span><br><span class="line">$ git branch &lt;name&gt;</span><br><span class="line">// 切换分支</span><br><span class="line">$ git checkout &lt;name&gt;</span><br><span class="line">// 等价于 创建 + 切换到分支</span><br><span class="line">$ git checkout -b &lt;name&gt;</span><br><span class="line">Switched to a new branch 'dev'</span><br><span class="line">    </span><br><span class="line">// 查看当前分支，命令会列出所有分支，当前分支前面会标一个*号。</span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line"></span><br><span class="line">// 合并指定分支到当前分支，例如 把 dev 合并到 master 上，需要在 master 上操作</span><br><span class="line">$ git merge dev</span><br><span class="line">// 合并方式</span><br><span class="line">// Fast forward 快速合并 删除分支后，会丢掉分支信息</span><br><span class="line">// --no-ff 表示禁用Fast forward，合并要创建一个新的commit，所以加上-m参数，把commit描述写进去</span><br><span class="line">$ git merge --no-ff -m "merge with no-ff" dev</span><br><span class="line">// 合并后的分支图</span><br><span class="line">// $ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">// *   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">// |\  </span><br><span class="line">// | * f52c633 (dev) add merge</span><br><span class="line">// |/  </span><br><span class="line">// *   cf810e4 conflict fixed</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// 删除分支</span><br><span class="line">$ git branch -d &lt;name&gt;</span><br><span class="line">// 强行删除分支，丢弃一个没有被合并过的分支时使用</span><br><span class="line">$ git branch -D &lt;name&gt;</span><br><span class="line"></span><br><span class="line">/* 分支策略</span><br><span class="line">在实际开发中，我们应该按照几个基本原则进行分支管理：</span><br><span class="line">首先，master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</span><br><span class="line">那在哪干活呢？干活都在 dev 分支上，也就是说，dev 分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到 master 上，在 master 分支发布1.0版本；</span><br><span class="line">你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。*/</span><br><span class="line"></span><br><span class="line">// 贮藏功能，存储当前工作区的修改，清空工作区</span><br><span class="line">$ git stash</span><br><span class="line">// 查看 贮藏 列表</span><br><span class="line">$ git stash list</span><br><span class="line">// 恢复 贮藏的工作区</span><br><span class="line">$ git stash apply // 恢复后，stash内容并不删除</span><br><span class="line">$ git stash pop   // 恢复后，删除 stash 内容 </span><br><span class="line">$ git stash apply stash@&#123;0&#125;  // 恢复到指定 stash</span><br><span class="line">// 删除 stash</span><br><span class="line">git stash drop</span><br><span class="line"></span><br><span class="line">// rebase 操作可以把本地未push的分叉提交历史整理成直线；</span><br><span class="line">// rebase 的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比</span><br><span class="line">$ git rebase</span><br><span class="line"></span><br><span class="line">// 打标签</span><br><span class="line">$ git tag v1.0</span><br><span class="line">// 查看所有标签</span><br><span class="line">$ git tag</span><br><span class="line">$ git tag v0.9 f52c633</span><br><span class="line">// 创建带有说明的标签，用-a指定标签名，-m指定说明文字</span><br><span class="line">$ git tag -a v0.1 -m "version 0.1 released" 1094adb    </span><br><span class="line">// 查看标签信息</span><br><span class="line">$ git show v0.9</span><br><span class="line">// 删除标签</span><br><span class="line">$ git tag -d v0.1</span><br><span class="line">// 推送某个标签到远程</span><br><span class="line">$ git push origin v1.0</span><br><span class="line">// 一次性推送全部尚未推送到远程的本地标签</span><br><span class="line">$ git push origin --tags</span><br><span class="line">// 标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除，然后，从远程删除</span><br><span class="line">$ git tag -d v0.9</span><br><span class="line">$ git push origin :refs/tags/v0.9</span><br></pre></td></tr></table></figure>
<h1 id="自定义设置"><a href="#自定义设置" class="headerlink" title="自定义设置"></a>自定义设置</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Git显示颜色</span><br><span class="line">$ git config --global color.ui true</span><br><span class="line">// 给一个命令配置别名。如 status 写成 st</span><br><span class="line">$ git config --global alias.st status</span><br><span class="line">// 修改撤销 reset HEAD 可以设置成 unstage</span><br><span class="line">$ git config --global alias.unstage 'reset HEAD'</span><br><span class="line"></span><br><span class="line">$ git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span><br></pre></td></tr></table></figure>
<p>在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。<code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理</p>
<p>忽略文件的原则是：</p>
<ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ol>
<p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p>
<p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = <span class="number">0</span></span><br><span class="line">    filemode = <span class="literal">true</span></span><br><span class="line">    bare = <span class="literal">false</span></span><br><span class="line">    logallrefupdates = <span class="literal">true</span></span><br><span class="line">    ignorecase = <span class="literal">true</span></span><br><span class="line">    precomposeunicode = <span class="literal">true</span></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">    url = git@github.com:michaelliao/learngit.git</span><br><span class="line">    fetch = +refs/heads<span class="comment">/*:refs/remotes/origin/*</span><br><span class="line">[branch "master"]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[alias]</span><br><span class="line">    last = log -1</span></span><br></pre></td></tr></table></figure>
<p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitconfig</span><br><span class="line">[alias]</span><br><span class="line">    co = checkout</span><br><span class="line">    ci = commit</span><br><span class="line">    br = branch</span><br><span class="line">    st = status</span><br><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">    email = your@email.com</span><br></pre></td></tr></table></figure>
<p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">参考链接</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[const/static/extern的使用]]></title>
      <url>http://liugangqiang.com/2017/05/19/const-static-extern%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="const-与宏的区别"><a href="#const-与宏的区别" class="headerlink" title="const 与宏的区别"></a>const 与宏的区别</h2><ul>
<li><code>编译时刻</code>:宏是预编译（编译之前处理），const是编译阶段。</li>
<li><code>编译检查</code>:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。</li>
<li><code>宏的好处</code>:宏能定义一些函数，方法。 const不能。</li>
<li><code>宏的坏处</code>:使用大量宏，容易造成编译时间久，每次都需要重新替换。</li>
</ul>
<blockquote>
<p>   注意：使用宏，并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见的常量，使用宏替换</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GGAccount @<span class="string">"accunt"</span></span></span><br><span class="line"><span class="comment">// 字符串常量</span></span><br><span class="line"><span class="keyword">static</span> NSString * <span class="keyword">const</span> account = @<span class="string">"accunt"</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSString *acc = GGAccount;</span><br><span class="line">    NSLog(@<span class="string">"acc:    %p---%p---%@"</span>, acc, &amp;acc, acc.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"account:%p---%p---%@"</span>, account, &amp;account, account.<span class="keyword">class</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">acc:    <span class="number">0x1084f9078</span>--<span class="number">-0x7ffee7705fe8</span>---__NSCFConstantString</span><br><span class="line">account:<span class="number">0x1084f9078</span>--<span class="number">-0x1084f9070</span>---__NSCFConstantString</span><br><span class="line"><span class="comment">// 变量 acc 和常量 account 指向的是同一块内存区域，即字符串常量 @"accunt" 所在的内存地址</span></span><br><span class="line"><span class="comment">// account 被 const 修饰，所以是常量，内存在常量区</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="const-作用：限制类型"><a href="#const-作用：限制类型" class="headerlink" title="const 作用：限制类型"></a>const 作用：限制类型</h2><ul>
<li><code>const</code>仅仅用来修饰右边的变量（基本数据变量p，指针变量*p）</li>
<li>被<code>const</code>修饰的变量是只读的。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; 		<span class="comment">// 定义变量</span></span><br><span class="line">a = <span class="number">100</span>;    		<span class="comment">// 允许修改值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b的值不允许修改，这两种写法作用相同</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// b = 10;			// 不允许修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const:修饰指针变量*p，带*的变量，就是指针变量.</span></span><br><span class="line"><span class="comment">// 定义一个 const 修饰的指针变量，const修饰的是 *p，即 p 访问的内存空间</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a; </span><br><span class="line"><span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">p = &amp;c;			   <span class="comment">// 允许修改 p 的值，即所指向的地址</span></span><br><span class="line"><span class="comment">// *p = 20;		   // 不允许修改 p 访问的内存空间的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const:修饰指针变量 p1</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p1 = &amp;a; <span class="comment">// const修饰的是 p，即 p 自身的内存空间</span></span><br><span class="line"><span class="comment">// p1 = &amp;c;			 // 不允许修改 p 的值，即所指向的地址</span></span><br><span class="line">*p1 = <span class="number">30</span>;			 <span class="comment">// 可以修改 p 访问的内存空间的值</span></span><br></pre></td></tr></table></figure>
<h2 id="static-作用"><a href="#static-作用" class="headerlink" title="static 作用"></a>static 作用</h2><ul>
<li>修饰局部变量：<ol>
<li>延长局部变量的生命周期，程序结束才会销毁。</li>
<li>局部变量只会生成一份内存，只会初始化一次。</li>
<li>改变局部变量的作用域。</li>
</ol>
</li>
<li>修饰全局变量<ol>
<li>只能在本文件中访问，修改全局变量的作用域，生命周期不会改</li>
<li>避免多个同名全局变量重复定义引发冲突</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static 修饰全局变量，只能在本文件中访问，生命周期不会改</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static 修饰局部变量</span></span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">        age++;</span><br><span class="line">        NSLog(@<span class="string">"%d----%p"</span>,age, &amp;age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果，可以看出 age 只初始化了一次，存在一份内存，每次循环使用的都是同一个变量</span></span><br><span class="line"><span class="number">1</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">2</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">3</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">4</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">5</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">6</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">7</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">8</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">9</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">10</span>---<span class="number">-0x1018e3f80</span></span><br></pre></td></tr></table></figure>
<h2 id="extern-作用"><a href="#extern-作用" class="headerlink" title="extern 作用"></a>extern 作用</h2><ul>
<li><p>只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量</p>
</li>
<li><p>先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个 .m 文件定义一个全局变量</span></span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个文件中，使用 extern 可以访问到这个变量</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">     [super viewDidLoad];</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">extern</span> <span class="keyword">int</span> p;</span><br><span class="line">     NSLog(@<span class="string">"%d"</span>,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="static-与-const-组合使用"><a href="#static-与-const-组合使用" class="headerlink" title="static 与 const 组合使用"></a>static 与 const 组合使用</h2><ul>
<li><p>作用：<code>static</code>与<code>const</code>组合可声明一个只读的静态变量</p>
</li>
<li><p>使用场景：在<code>一个文件中</code>经常使用的字符串常量，定义成静态全局只读变量，可以使用<code>static</code>与<code>const</code>组合。如：Cell 的 ReuseIdentifier </p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开发中常用 static 修饰全局变量，只改变作用域，防止重复声明全局变量</span></span><br><span class="line"><span class="comment">// 开发中声明的全局变量，有些不希望外界改动，只允许读取。</span></span><br><span class="line"><span class="comment">// 比如一个基本数据类型不希望别人改动</span></span><br><span class="line"><span class="comment">// 声明一个静态的全局只读常量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开发中经常拿到 key 修改值，因此用 const 修饰 key，表示 key 只读，不允许修改。</span></span><br><span class="line"><span class="keyword">static</span> NSString * <span class="keyword">const</span> key = @<span class="string">"name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cell 的重用字符串，每次获取 cell 时都会使用，创建一个静态常量，避免反复创建</span></span><br><span class="line"><span class="keyword">static</span> NSString * <span class="keyword">const</span> cellIdentifier = @<span class="string">"cellIdentifier"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="extern-与-const-组合使用"><a href="#extern-与-const-组合使用" class="headerlink" title="extern 与 const 组合使用"></a>extern 与 const 组合使用</h2><ul>
<li><p>作用：<code>extern</code>与<code>const</code>组合，只需要定义一份全局变量，多个文件共享。</p>
</li>
<li><p>使用场景：在<code>多个文件中</code>经常使用的同一个字符串常量，可以使用<code>extern</code>与<code>const</code>组合</p>
</li>
<li><p>全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个<code>GlobeConst</code>文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">extern</span> NSString * <span class="keyword">const</span> nameKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line">NSString * <span class="keyword">const</span> nameKey = @<span class="string">"name"</span>;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS内存分布]]></title>
      <url>http://liugangqiang.com/2017/05/18/iOS%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</url>
      <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p><strong>随机存取存储器</strong>（random access memory，RAM）又称作“<a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8" target="_blank" rel="external">随机存储器</a>”，是与CPU直接交换数据的内部存储器，也叫主存(内存)。</p>
<ul>
<li>存储单元的内容可按需随意取出或存入，且存取的速度很快，与存储单元的位置无关。</li>
<li>这种存储器在断电时将丢失其存储内容，故主要用于存储 <em>短时间使用</em> 的程序。</li>
<li>通常作为操作系统或其他正在运行中的程序的临时数据存储媒介。</li>
</ul>
<h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>ROM是<a href="https://baike.baidu.com/item/%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8" target="_blank" rel="external">只读存储器</a>（Read-Only Memory）的简称，是一种只能读出事先所存数据的固态半导体存储器。</p>
<ul>
<li>所存数据稳定，断电后所存数据也不会改变。</li>
<li>其结构较简单，读出较方便，因而常用于存储各种固定程序和数据。</li>
<li>为便于使用和大批量生产，进一步发展了各种可读写存储器，如快闪存储器(Flash memory)。</li>
</ul>
<p>在计算机系统运行应用时，会把APP从ROM里面拷贝到内存（RAM），然后从内存里面执行代码。运行的应用程序的数据都是保存在内存中的，不同类型的数据，保存的内存区域不同。</p>
<a id="more"></a>
<h1 id="iOS的内存"><a href="#iOS的内存" class="headerlink" title="iOS的内存"></a>iOS的内存</h1><p>iOS的内存分布与C语言的类似，分为：</p>
<ol>
<li>代码区</li>
<li>文字常量区</li>
<li>全局区/静态区(Static）</li>
<li>堆区(Heap)</li>
<li>栈区(Stack)</li>
</ol>
<h2 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h2><p>存放函数的二进制代码</p>
<h2 id="常量区"><a href="#常量区" class="headerlink" title="常量区"></a>常量区</h2><p>存放常量字符串以及其他定义的常量，程序结束系统释放</p>
<h2 id="全局区-静态区-Static）"><a href="#全局区-静态区-Static）" class="headerlink" title="全局区/静态区(Static）"></a>全局区/静态区(Static）</h2><p>全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后由系统释放。</p>
<blockquote>
<p>注意：全局区又可分为：</p>
<p>未初始化全局区： bss段</p>
<p>初始化全局区：data段</p>
<p>举例：int a——未初始化的；int a = 10——已初始化的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p;    <span class="comment">// 全局未初始化区</span></span><br></pre></td></tr></table></figure>
<h2 id="堆区-Heap"><a href="#堆区-Heap" class="headerlink" title="堆区(Heap)"></a>堆区(Heap)</h2><ul>
<li>堆区的内存分配使用的是alloc，代码中创建的对象一般都存在堆中</li>
<li>需要程序猿管理内存；</li>
<li>ARC的内存的管理，是编译器再便宜的时候自动添加 retain、release、autorelease；</li>
<li>堆区的地址是从低到高分配）</li>
</ul>
<h2 id="栈区-Stack"><a href="#栈区-Stack" class="headerlink" title="栈区(Stack)"></a>栈区(Stack)</h2><ul>
<li>存放的局部变量、先进后出、一旦出了作用域就会被销毁；函数跳转地址，现场保护等；</li>
<li>程序猿不需要管理栈区变量的内存；</li>
<li>栈区地址从高到低分配；   </li>
</ul>
<p><img src="/uploads/iOSMemoryLayout/iOSMemoryLayout-image.png" alt=""></p>
<h1 id="具体代码分析"><a href="#具体代码分析" class="headerlink" title="具体代码分析"></a>具体代码分析</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别创建相同的全局变量</span></span><br><span class="line"></span><br><span class="line">NSInteger a = <span class="number">100</span>;</span><br><span class="line">NSString *str1 = @<span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">const</span> NSString *str2 = @<span class="string">"123"</span>;</span><br><span class="line">NSString *strEm1 = @<span class="string">""</span>;</span><br><span class="line">NSString *strEm2 = @<span class="string">""</span>;</span><br><span class="line">NSInteger b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSString *str3 = @<span class="string">"123"</span>;</span><br><span class="line">    NSString *strEm3 = @<span class="string">""</span>;</span><br><span class="line">    NSMutableString *mutStr = [[NSMutableString alloc] init];</span><br><span class="line">    NSString *strEm4 = [NSString <span class="built_in">string</span>];</span><br><span class="line">    NSString *strEm5 = [[NSString alloc] init];</span><br><span class="line">    NSLog(@<span class="string">"str1:  %p---%p---%@"</span>, str1, &amp;str1, str1.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"str2:  %p---%p---%@"</span>, str2, &amp;str2, str2.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"str3:  %p---%p---%@"</span>, str3, &amp;str3, str3.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"strEm1:%p---%p---%@"</span>, strEm1, &amp;strEm1, strEm1.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"strEm2:%p---%p---%@"</span>, strEm2, &amp;strEm2, strEm2.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"strEm3:%p---%p---%@"</span>, strEm3, &amp;strEm3, strEm3.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"strEm4:%p---%p---%@"</span>, strEm4, &amp;strEm4, strEm4.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"strEm5:%p---%p---%@"</span>, strEm5, &amp;strEm5, strEm5.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"mutStr:%p---%p---%@"</span>, mutStr, &amp;mutStr, mutStr.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"a:     %p"</span>, &amp;a);</span><br><span class="line">    NSLog(@<span class="string">"b:     %p"</span>, &amp;b);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">str1:  <span class="number">0x10e117070</span>--<span class="number">-0x10e118048</span>---__NSCFConstantString</span><br><span class="line">str2:  <span class="number">0x10e117070</span>--<span class="number">-0x10e118050</span>---__NSCFConstantString</span><br><span class="line">str3:  <span class="number">0x10e117070</span>--<span class="number">-0x7ffee1ae7fe8</span>---__NSCFConstantString</span><br><span class="line">    </span><br><span class="line">strEm1:<span class="number">0x10e117090</span>--<span class="number">-0x10e118058</span>---__NSCFConstantString</span><br><span class="line">strEm2:<span class="number">0x10e117090</span>--<span class="number">-0x10e118060</span>---__NSCFConstantString</span><br><span class="line">strEm3:<span class="number">0x10e117090</span>--<span class="number">-0x7ffee1ae7fe0</span>---__NSCFConstantString</span><br><span class="line">    </span><br><span class="line">strEm4:<span class="number">0x10e713338</span>--<span class="number">-0x7ffee1ae7fd0</span>---__NSCFConstantString</span><br><span class="line">strEm5:<span class="number">0x10e713338</span>--<span class="number">-0x7ffee1ae7fc8</span>---__NSCFConstantString</span><br><span class="line">mutStr:<span class="number">0x60400025caa0</span>--<span class="number">-0x7ffee1ae7fd8</span>---__NSCFString</span><br><span class="line">a:     <span class="number">0x10e118040</span></span><br><span class="line">b:     <span class="number">0x10e118068</span></span><br></pre></td></tr></table></figure>
<p>由此可以看出：</p>
<ol>
<li><p>直接以<code>@&quot;</code>创建的字符串对象都存储在字符串常量区，而且相同的字符串只会在内存中存在一份。其他用到此字符串的变量/常量指针指向这块内存。</p>
</li>
<li><p>全局变量储存在全局区，如 <code>a</code>，<code>b</code>，<code>str1</code>，<code>str2</code>，<code>strEm1</code>，<code>strEm2</code>，其中<code>str1</code>，<code>str2</code>，<code>strEm1</code>，<code>strEm2</code>是指针，指向的字符串常量对象在常量区。</p>
</li>
<li><p><code>str3</code>，<code>strEm3</code>是局部变量，内存在栈区，指向的字符串常量对象在常量区。</p>
</li>
<li><p><code>strEm4</code>，<code>strEm5</code>也是局部变量，内存在栈区，但是其指向的对象是用类创建的空字符串（类型<code>__NSCFConstantString</code>），是预先创建好的，存储在全局区。</p>
</li>
<li><p><code>mutStr</code>可变字符串指针，内存在栈区；指向的可变字符串对象在堆区。一般创建的对象都存储在堆区，指针变量指向这些对象，局部变量本身的内存在栈区。</p>
</li>
<li><p><code>@&quot;123&quot;</code>本身就是常量，所以 <code>str2</code>之前的 <code>const</code>的写与不写没什么区别。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C语言的内存分布]]></title>
      <url>http://liugangqiang.com/2017/05/09/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</url>
      <content type="html"><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>经典的 C 语言内存分布包括以下 5 个部分:</p>
<ol>
<li>代码段 (Text segment)</li>
<li>初始化数据段 (Initialized data segment)</li>
<li>未初始化数据段 (Uninitialized data segment)</li>
<li>堆区 (Heap)</li>
<li>栈区 (Stack)</li>
</ol>
<a id="more"></a>
<p><img src="/uploads/memoryLayoutC.jpg" alt=""></p>
<p><img src="/uploads/memoryLayoutD.png" alt=""></p>
<p>这是 C 语言程序运行中的经典内存布局，从低地址区域到高以此排布是：代码段、初始化数据段、未初始化数据段、堆、栈。</p>
<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>代码段 (Text segment)，又叫做文本段。存放 CPU 执行的机器指令 (machine instructions)。</p>
<ul>
<li>通常，代码区是可以共享的（另外的执行程序可以调用它），因为对于频繁操作被执行的的程序，只需要在内存中有一份代码即可。</li>
<li>代码区通常是只读的，防止程序意外的修改了它的指令。</li>
<li>代码区在低地址区域，以防止堆或者栈的溢出</li>
</ul>
<h2 id="初始化数据段"><a href="#初始化数据段" class="headerlink" title="初始化数据段"></a>初始化数据段</h2><p>初始化数据段 (Initialized data segment) 是程序的虚拟地址空间的一部分，它包含由程序员初始化的全局变量和静态变量。</p>
<ul>
<li>数据区不是只读的，因为变量的值可以在运行时改变</li>
<li>该区可进一步分为初始化只读区和初始化读写区</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个在任何函数外的全局变量，存储在初始化读写区域中</span></span><br><span class="line"><span class="keyword">int</span> maxCount = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个静态数据</span></span><br><span class="line"><span class="comment">// 字符文本 “hello world” 存储在初始化只读区域中</span></span><br><span class="line"><span class="comment">// 指针变量 string 存储在在初始化读写区域中</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span> = “hello world”;</span><br></pre></td></tr></table></figure>
<h2 id="未初始化数据段"><a href="#未初始化数据段" class="headerlink" title="未初始化数据段"></a>未初始化数据段</h2><p>未初始化数据段 (Uninitialized data segment)，亦称BSS区，BSS这个叫法是根据一个早期的汇编运算符而来，这个汇编运算符标志着一个块的开始。</p>
<ul>
<li>BSS区从初始化数据区的末尾开始，包含所有全局变量和静态变量，这些变量初始化为零或源代码中没有显式初始化</li>
<li>BSS区的数据在程序开始执行之前被内核初始化为 0 或者空指针（NULL）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个变量都会被存储在未初始化数据区</span></span><br><span class="line"><span class="keyword">long</span> sum[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i；</span><br></pre></td></tr></table></figure>
<h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><p>栈区（stack）。由编译器自动分配释放，存放函数的参数值、局部变量的值、函数的返回值等。</p>
<ul>
<li>其操作方式类似于数据结构中的栈。</li>
<li>除了存储局部变量的值外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。</li>
<li>由于栈的先进先出特点，所以栈特别方便用来保存/ 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li>
</ul>
<h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p>堆 (heap) 是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。</p>
<ul>
<li>一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 </li>
<li>当进程调用<code>malloc</code>等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）</li>
<li>当利用<code>free</code>等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</li>
<li>在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并将在内存中为这些段分配空间。栈段亦由操作系统分配和管理，而不需要程序员显示地管理；堆段由程序员自己管理，即显式地申请和释放空间。</li>
</ul>
<h2 id="堆区和栈区的区别"><a href="#堆区和栈区的区别" class="headerlink" title="堆区和栈区的区别"></a>堆区和栈区的区别</h2><h3 id="管理分配方式"><a href="#管理分配方式" class="headerlink" title="管理分配方式"></a>管理分配方式</h3><p>   栈的分配和释放是由编译器完成的，栈的动态分配由<code>alloca()</code>函数完成，无需程序员手工控制；</p>
<p>   堆都是程序中由<code>malloc()</code>函数动态申请分配并由<code>free()</code>函数释放的，申请释放工作由程序员控制，容易产生内存泄漏。</p>
<h3 id="空间大小"><a href="#空间大小" class="headerlink" title="空间大小"></a>空间大小</h3><p>   栈是向低地址扩展的数据结构，是一块连续的内存区域。栈顶的地址和栈的最大容量是系统预先规定好的，当超出申当申请的空间超过栈的剩余空间时，将提示溢出，用户能从栈获得的空间较小。在 WINDOWS 下，栈的大小是2M；</p>
<p>   堆是向高地址扩展的数据结构，是不连续的内存区域。因为系统是用链表来存储空闲内存地址的，且链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间较灵活，也较大。</p>
<h3 id="是否产生碎片"><a href="#是否产生碎片" class="headerlink" title="是否产生碎片"></a>是否产生碎片</h3><p>   对于堆来讲，频繁的malloc/free（new/delete）势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低（虽然程序在退出后操作系统会对内存进行回收管理）；</p>
<p>   对于栈来讲，则不会存在这个问题。</p>
<h3 id="增长方向"><a href="#增长方向" class="headerlink" title="增长方向"></a>增长方向</h3><p>   堆的增长方向是向上的，即向着内存地址增加的方向；</p>
<p>   栈的增长方向是向下的，即向着内存地址减小的方向。</p>
<h3 id="分配效率"><a href="#分配效率" class="headerlink" title="分配效率"></a>分配效率</h3><p>   栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行。系统自动分配，速度较快，程序员是无法控制的；</p>
<p>   堆则是C函数库提供的，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大的空间，如果没有足够大的空间（可能是由于内存碎片太多），就有需要操作系统来重新整理内存空间，这样就有机会分到足够大小的内存，然后返回。由<code>new</code>分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。</p>
<h3 id="申请后系统的响应"><a href="#申请后系统的响应" class="headerlink" title="申请后系统的响应"></a>申请后系统的响应</h3><p>   栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p>   堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的<code>delete</code>语句才能正确的释放本内存空间。由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>
<h3 id="存储的内容"><a href="#存储的内容" class="headerlink" title="存储的内容"></a>存储的内容</h3><p>   堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</p>
<p>   栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量（静态变量不入栈）。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。栈中的内存是在程序编译完成以后就可以确定的，不论占用空间大小，还是每个变量的类型。</p>
<h3 id="防止越界"><a href="#防止越界" class="headerlink" title="防止越界"></a>防止越界</h3><p>   无论是堆还是栈，都要防止越界现象的发生（除非故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生意想不到的结果。debug相当困难。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS分词]]></title>
      <url>http://liugangqiang.com/2016/10/25/iOS%E5%88%86%E8%AF%8D/</url>
      <content type="html"><![CDATA[<p>最近锤子科技发布新手机，手机推出重大功能分词（Big Bang），其实 iOS 拥有分词的 API，代码如下</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (NSArray *)stringTokenizerWithWord:(NSString *)word &#123;</span><br><span class="line">    NSMutableArray *keyWords = [NSMutableArray <span class="keyword">new</span>];</span><br><span class="line">    CFStringTokenizerRef ref = CFStringTokenizerCreate(<span class="literal">NULL</span>, (__bridge CFStringRef)word, CFRangeMake(<span class="number">0</span>, word.length),kCFStringTokenizerUnitWord,<span class="literal">NULL</span>);</span><br><span class="line">    CFRange range;</span><br><span class="line">    NSString *keyWord;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        CFStringTokenizerAdvanceToNextToken(ref);</span><br><span class="line">        range = CFStringTokenizerGetCurrentTokenRange(ref);</span><br><span class="line">        <span class="keyword">if</span> (range.length == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        keyWord = [word substringWithRange:NSMakeRange(range.location, range.length)];</span><br><span class="line">        [keyWords addObject:keyWord];</span><br><span class="line">    &#125; <span class="keyword">while</span> (range.length &gt; <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> keyWords;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CocoaPods安装和使用]]></title>
      <url>http://liugangqiang.com/2016/07/04/CocoaPods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="CocoaPods-简介"><a href="#CocoaPods-简介" class="headerlink" title="CocoaPods 简介"></a>CocoaPods 简介</h2><p>在 iOS 应用的开发过程中，经常会使用到第三方的开源类库，例如AFNetWorking、SDWebimage 等等。通常，我们会把第三方的框架从网上下载下来， 再拖入到我们的项目中，但是这样一个一个的操作十分繁琐，而且存在<strong>第三方库更新不及时，不易集中管理的问题</strong>。<br><a href="https://cocoapods.org" target="_blank" rel="external">CocoaPods</a> 是为解决此类问题而产生的第三方类库管理工具。它将第三方库集中到一起管理，只需要一行终端命令就第三方库进行安装、更新等处理。绝大部分有名的开源类库，都支持CocoaPods。作为iOS开发程序员，掌握 CocoaPods 的使用时必不可少的基本技能之一。</p>
<a id="more"></a>
<h2 id="CocoaPods-的安装"><a href="#CocoaPods-的安装" class="headerlink" title="CocoaPods 的安装"></a>CocoaPods 的安装</h2><h3 id="安装配置-Ruby-环境"><a href="#安装配置-Ruby-环境" class="headerlink" title="安装配置 Ruby 环境"></a>安装配置 Ruby 环境</h3><h4 id="检查-Ruby-环境（安装）"><a href="#检查-Ruby-环境（安装）" class="headerlink" title="检查 Ruby 环境（安装）"></a>检查 Ruby 环境（安装）</h4><p>CocoaPods 是使用 Ruby 语言编写，所以安装之前需要先安装 Ruby 环境。默认情况下，Mac OS X 系统已经安装好 Ruby。在终端直接使用以下命令，确认系统系统 Ruby 的版本信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ruby --version</span><br><span class="line">或者 </span><br><span class="line">$ ruby --v</span><br><span class="line"></span><br><span class="line">// 输出版本信息大致如下</span><br><span class="line">// ruby 2.0.0p648 (2015-12-16 revision 53162) [universal.x86_64-darwin15]</span><br></pre></td></tr></table></figure></p>
<p>如果没有安装 Ruby，<a href="https://github.com/ruby-china/ruby-china/wiki/Mac-OS-X-上安装-Ruby" target="_blank" rel="external">点击这里进行安装</a></p>
<h4 id="更换-Ruby-源链接"><a href="#更换-Ruby-源链接" class="headerlink" title="更换 Ruby 源链接"></a>更换 Ruby 源链接</h4><p>Ruby 默认的源为 <code>https://rubygems.org</code>，因为这个源在墙外，直接访问这个源使用 CocoaPods 速度会非常慢（很可能安装失败）。<del>但是，我们可以使用淘宝的 Ruby 镜像来访问 CocoaPods</del>（淘宝镜像服务已经停止，由<code>https://gems.ruby-china.org/</code>接管）。</p>
<p>查看 Ruby 源。如果网址为 <del><code>https://ruby.taobao.org/</code></del>（<code>https://gems.ruby-china.org/</code>），则说明之前已经进行过更换，可以直接安装 CocoaPods。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span><br><span class="line">// *** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">// https://rubygems.org/</span><br></pre></td></tr></table></figure></p>
<p>移除 Ruby 源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --remove https://rubygems.org/</span><br><span class="line">// https://rubygems.org/ removed from sources</span><br></pre></td></tr></table></figure></p>
<p>添加新的 Ruby 源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -a https://gems.ruby-china.org/</span><br><span class="line">// https://gems.ruby-china.org/ added to sources</span><br><span class="line"></span><br><span class="line">// $ gem sources -a https://ruby.taobao.org/ 已废弃</span><br></pre></td></tr></table></figure></p>
<p>检查是否添加成功<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span><br></pre></td></tr></table></figure></p>
<p>在终端中显示如下结果时，说明更换成功<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//gems.ruby-china.org/</span></span><br></pre></td></tr></table></figure></p>
<h3 id="安装-CocoaPods"><a href="#安装-CocoaPods" class="headerlink" title="安装 CocoaPods"></a>安装 CocoaPods</h3><p>在终端运行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure></p>
<p>运行之后，需要输入电脑的密码，并且没有密码输入位数的提醒。密码输入正确之后就进行安装了，安装可能需要很长时间，耐心等待。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Fetching: cocoapods-core<span class="number">-1.0</span><span class="number">.1</span>.gem (<span class="number">100</span>%)</span><br><span class="line">Successfully installed cocoapods-core<span class="number">-1.0</span><span class="number">.1</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Parsing documentation <span class="keyword">for</span> cocoapods<span class="number">-1.0</span><span class="number">.1</span></span><br><span class="line">Installing ri documentation <span class="keyword">for</span> cocoapods<span class="number">-1.0</span><span class="number">.1</span></span><br><span class="line"><span class="number">13</span> gems installed</span><br></pre></td></tr></table></figure></p>
<p>出现类似这样的提示，就说明 CocoaPods 安装成功了</p>
<h2 id="CocoaPods-的使用"><a href="#CocoaPods-的使用" class="headerlink" title="CocoaPods 的使用"></a>CocoaPods 的使用</h2><h3 id="创建-Podfile-文件"><a href="#创建-Podfile-文件" class="headerlink" title="创建 Podfile 文件"></a>创建 Podfile 文件</h3><p>在终端定位到需要使用 CocoaPods 的项目的工程目录，使用命令创建一个 Podfile 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /Users/new/Desktop/YourProject</span><br><span class="line">$ pod init</span><br></pre></td></tr></table></figure></p>
<p>出现如下文件<br><img src="/uploads/Cocopods-image1.png" alt=""><br>创建成功</p>
<h3 id="编辑-Podfile-文件"><a href="#编辑-Podfile-文件" class="headerlink" title="编辑 Podfile 文件"></a>编辑 Podfile 文件</h3><p>打开 Podfile 文件<br><img src="/uploads/Cocopods-image2.png" alt=""><br>带<code>#</code>的为注释</p>
<ol>
<li>删除掉第二行的<code>#</code>,为你的项目设置最低支持的 iOS 版本。</li>
<li>在 <code>target &#39;YourProject&#39; do</code> 和 <code>end</code> 之间输入你想导入的框架，如 AFNetworking:<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target 'YourProject' do</span><br><span class="line">  # Uncomment this line if you're using Swift or would like to use dynamic frameworks</span><br><span class="line">  # use_frameworks!</span><br><span class="line">  # Pods for YourProject</span><br><span class="line">pod ‘AFNetworking’</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="执行命令安装-CocoaPods"><a href="#执行命令安装-CocoaPods" class="headerlink" title="执行命令安装 CocoaPods"></a>执行命令安装 CocoaPods</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod install</span><br></pre></td></tr></table></figure>
<p>等待执行完毕，即可完成 CocoaPods 的安装。</p>
<p>另外，也可以使用更新 CocoaPods 版本并进行安装<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod update</span><br></pre></td></tr></table></figure></p>
<p><code>pod install</code> 和 <code>pod update</code>执行过程中都会更新 podpec 的索引，有时速度会很慢，为了提高速度，可以输入如下命令，在不更新索引的情况下执行命令：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod install --no-repo-update</span><br></pre></td></tr></table></figure></p>
<p>也可以在每条命令后加 <code>--verbose</code> 显示详细的命令执行内容</p>
<h3 id="项目打开方式改变"><a href="#项目打开方式改变" class="headerlink" title="项目打开方式改变"></a>项目打开方式改变</h3><p>安装成功后，项目目录下回多出几个文件，以后打开文件要使用箭头所指白色的<code>.xcworkspace</code>文件，不再使用蓝色的<code>.xcodeproj</code>文件。<br><img src="/uploads/Cocopods-image3.png" alt=""><br>项目打开之后，层级结构如下<br><img src="/uploads/Cocopods-image5.png" alt=""><br>上边的是我们原先的项目代码，下边的是 CocoaPods 文件以及它导入的第三方库。</p>
<p>需要注意的是，要引用 CocoaPods 导入的第三方库，要使用 <code>&lt;&gt;</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;AFNetworking.h&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="添加或者删除第三方库"><a href="#添加或者删除第三方库" class="headerlink" title="添加或者删除第三方库"></a>添加或者删除第三方库</h3><p>CocoaPods 安装完成后，再安装或者删除第三方库，只需要编辑 Podfile 文件添加或者删除对应的引用，然后执行<code>pod install</code> 或者 <code>pod update</code>命令即可。<br><img src="/uploads/Cocopods-image4.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://liugangqiang.com/2016/06/17/hello-world/</url>
      <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>Welcome to <em>The Corner Grocery ! I`m </em>刚刚_ .</p>
<a id="more"></a>
]]></content>
    </entry>
    
  
  
</search>
