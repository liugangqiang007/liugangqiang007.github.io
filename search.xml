<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[iOS项目Project和Target配置详解]]></title>
      <url>http://www.liugangqiang.com/2018/05/18/iOS%E9%A1%B9%E7%9B%AEProject%E5%92%8CTarget%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>iOS 项目一般使用 Xcode 进行开发。项目创建完成后，点击项目名称，在项目导航栏的右侧板面上显示有 PROJECT 和 TARGETS 两部分。iOS 项目的开发环境搭建主要就是基于我们项目的 Project 和 Target 进行展开的，下面对这两部分进行详解，<a href="https://developer.apple.com/library/content/featuredarticles/XcodeConcepts/Concept-Projects.html#//apple_ref/doc/uid/TP40009328-CH5-SW1" target="_blank" rel="external">参考官方文档</a>。</p>
<p><img src="iOS项目Project和Target配置详解.assets/ProjectAndTargets_01.jpeg" alt=""></p>
<a id="more"></a>
<h1 id="Project、Target、Build-Settings、Workspace和Scheme"><a href="#Project、Target、Build-Settings、Workspace和Scheme" class="headerlink" title="Project、Target、Build Settings、Workspace和Scheme"></a>Project、Target、Build Settings、Workspace和Scheme</h1><h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><p>一个 project 是构建一个或多个软件产品所需的所有文件、资源、信息/配置的存储库（repository）。一个 project 包含所有用于构建产品（build your products）的元素，并维护这些元素之间的关系。它可以包含一个或多个 Targets。一个project 为所有的 targets 定义默认的 build setting（每一个 target 可以自定义它们的 build setting，这些自定义的 setting会覆盖 project 默认的 build setting）。</p>
<p>一个 Xcode project 文件包含以下几部分信息：</p>
<ul>
<li>相关源文件（source files）<ul>
<li>源代码，包括 .h 和 .m 文件</li>
<li>libraries 和 frameworks，内部的和外部的</li>
<li>资源文件</li>
<li>图片资源文件</li>
<li>nib 文件</li>
</ul>
</li>
<li>用于在结构导航器（ structure navigator）中组织源文件（source files）的组（groups）</li>
<li>Project-level build configurations（项目级构建配置），可以有多个，例如 debug 和 release buid setting</li>
<li>Targets，每个 target 指定：<ul>
<li>通过 project 构建一个产品（product）的引用</li>
<li>构建该产品（product）所需要的资源文件的引用</li>
<li>用于构建该产品（product）的构建配置（build configurations），包括对其他 Targets 和 settings 的依赖；如果 targets 的 build configurations 没有配置时，使用 Project-level build configurations</li>
</ul>
</li>
<li>用来 debug 和 test 程序的可执行环境，包括：<ul>
<li>从 Xcode run 或 debug 时启动的可执行文件</li>
<li>要传递给可执行文件的命令行参数</li>
<li>程序 run 时要设置的环境变量</li>
</ul>
</li>
</ul>
<p>一个 project 可以单独存在，也可以包含在一个 workspace 里。</p>
<h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>一个 target 确定一个产品（product）的构建，包括一些指令（instructions）——怎么从一个 project 或者 workspace 的一堆文件导出一个产品。一个 target 对应一个 product，它管理着一个 product 的 build system 的“输入”（一堆源文件和一些处理这些源文件的 instruction）。一个 project 可以包含多个 target，每一个 targe 生成一个 product。</p>
<p>构建一个 product 的 instructions （指令）的表现形式是 build settings 和 build phases，可以在 Xcode project editor 中检查和编辑。一个 target 的 build settings 继承 project 的 build settings，但是可以重写覆盖 project settings。同一时间里只有一个 active target ，由 Xcode Scheme 指定。</p>
<p>一个 target 和它创建的 product 可以跟其他 target 关联。如果一个 target 需要另一个的 <code>output</code>以完成构建，可以说成第一个 target 依赖第二个。</p>
<p>如果两个 targets 在同一个 workspace 中，Xcode 可以发现他们的依赖关系，从而 builds the products 按照特定的顺序。这样的关系被称为“implicit dependency（隐式依赖）”。可以为俩个 targets 指定明确的依赖或者不依赖关系在 build setting 里面。</p>
<p>例如：在同一个 workspace 中，可以构建一个 library 和一个链接这个 library 的 application。Xcode 可以发现这种依赖关系，并首先自动构建 library。但是，如果想链接某个版本的 library，就需要在  build settings 明确依赖关系，该依赖项会覆盖隐式依赖项。</p>
<h2 id="Build-Settings"><a href="#Build-Settings" class="headerlink" title="Build Settings"></a>Build Settings</h2><p>一个 build Setting 是一个变量，包含着怎么 build product 的处理信息。例如，可以指定 Xcode 传递给编译器的选项</p>
<p>Build settings 有 project 和 target 两个级别，project－level 中的 build setting 适用项目中所有的 targets，只要该项 setting 没有被 target 级别的重写覆盖。</p>
<p>每个 target 管理着创建一个 product 的源文件，一个 build configuration 指定一组 build settings，用于以特定的方式构建一个 product。例如，通常有 debug 和 release 俩种分开的 build configurations。</p>
<p>一个 build Setting 包含两个部分：setting title（标题） 和 definition（定义）——类似于 key-value 结构。前者标示该 build Setting，并且可以被用在其他的settings。后者是一个常量或一个表达式，用于确定 build setting 的值。一个 build setting 也可以有一个显示名称，被用于在 Xcode 界面中显示 build setting。</p>
<p>另外，当你通过 project 模板新建一个 project 时，Xcode 会生成一个默认的 build settings，你也可以为 project 或者某个 target 创建自定义build settings。你还可以设定 conditional build settings，一个 conditional build setting 的值取决于是否满足一个或多个先决条件。这个机制也可以被用在指定用于基于目标架构构建产品的SDK。</p>
<h2 id="Workspace"><a href="#Workspace" class="headerlink" title="Workspace"></a>Workspace</h2><p>一个 workspace 是一个 Xcode 文档，groups(组合)不同的project、文档，所以你可以同时管理多个project。一个 workspace 可以包含任意数量的 Xcode projects 和其他文件。除了组织每个 Xcode projects 中的所有文件外，workspace 还提供 projects 与他们各自 targets 之间的隐式/显示关联。</p>
<h3 id="Workspace-扩展-workflows-的范围"><a href="#Workspace-扩展-workflows-的范围" class="headerlink" title="Workspace 扩展 workflows 的范围"></a>Workspace 扩展 workflows 的范围</h3><p>一个工程文件（project file）包含指向 project 中所有文件的指针，build configurations 和 project 的其他信息。在Xcode 3 之前，projects 之前关联是很复杂的事情，大多数工作流仅限于单个 project。从 Xcode 4 之后，你可以创建一个 workspace 去包含多个 projects 和其他文件。</p>
<p>除了提供被包含在 Xcode project 中的所有文件的访问外，workspace 还拓展许多重要的 Xcode workflows 的范围。例如，由于 indexing（文件索引）遍布整个 workspace，所以，在 workspace 中， code completion、Jump to Definition 和所有其他的内容感知特性，可以在所有 projects 中无缝衔接运作。因为 refactoring operations（重构操作）横跨整个 workspace 的所有内容，所以，你可以在一个 framework project 中重构 API，并且在其他 application projects 中使用这个 framework。构建时，一个 project 可以利用 workspace 中其他 projects 的 products。</p>
<p>workspace 文档包含被囊括的 projects 和其他文件，不再有其他数据。一个 project 可以被多个 workspace 持有。下图展示一个 workspace 包含两个 Xcode projects 以及 一个文档 project。</p>
<p>备注：workspace 类似.xcodeproj文件，他不是一个文件夹，而是一个有管理、索引作用的一个文件。</p>
<p><img src="iOS项目Project和Target配置详解.assets/ProjectAndTargets_02.jpg" alt="art/workspace_hierarchy.jpg"></p>
<h3 id="Workspaces-中的-Projects-共享-Build-Directory"><a href="#Workspaces-中的-Projects-共享-Build-Directory" class="headerlink" title="Workspaces 中的 Projects 共享 Build Directory"></a>Workspaces 中的 Projects 共享 Build Directory</h3><p>默认情况下，workspace 中的所有 Xcode projects 都构建在同一目录中（称为工作区构建目录 - works pace build directory）。每一个 workspace 都有自己的 build directory。因为 workspace 中 所有 projects 的所有文件都唯一同一个  build directory，所以所有这些文件对每个项目都是可见的。因此，如果两个或多个 projects 使用同一个 library（库），你不需要把他们分别复制到每个 project 文件夹中。</p>
<p>Xcode 会检查 build directory 里的文件并发现其中的隐式依赖关系（implicit dependencies）。例如，workspace 中包含的一个 project 生成的库，被另一个 project 引用，Xcode 会在生成另一个 project 之前自动生成这个库，即使 build configuration 未标明这种显示依赖（dependency explicit）。如果需要，你可以进行显示设置覆盖这种隐式依赖。对于“显示依赖”，你必须创建项目引用。</p>
<p>workspace 中的每一个 project 都有保持自己的特性。你能通过 project 的打开方式控制 project 受不受其他 projects 的影响，如单独打开 project 而不是通过 workspace。由于 project 可以属于多个 workspace，您可以以任意数量的组合来处理 projects，而不必重新配置任何 project 或 workspace。</p>
<p>你可以使用 workspace 默认的 build directory，也可以自己指定一个。注意：如果一个 project 指定一个 build directory，这个 build directory 会覆盖全部所在的 workspace 里的默认 build directory。</p>
<h2 id="Xcode-Scheme"><a href="#Xcode-Scheme" class="headerlink" title="Xcode Scheme"></a>Xcode Scheme</h2><p>一个 Xcode Scheme（方案）定义三样东西：一个要生成的目标（targets to build）的集合、building 时使用的配置（configuration）、以及要执行的测试集合。</p>
<p>你可以拥有任意数量的 scheme，但一次只能有一个是活跃状态（active），你可以指定 scheme 是否储存在 project 中（这种方案下，scheme 在每一个包含这个 project 的 workspace 中都可用），或者储存在 workspace 中（仅在当前 workspace 中可用）。选择要激活的 scheme 时，可以选择运行目标（设备）。</p>
<h1 id="Project-和-Target-的属性设置"><a href="#Project-和-Target-的属性设置" class="headerlink" title="Project 和 Target 的属性设置"></a>Project 和 Target 的属性设置</h1><p>Project 和 Target 的属性设置，如下边两张图所示，上边一张是 project 的，只包含 <code>Info</code> 和 <code>Build Settings</code> 两个选项卡，只是对项目资源进行简单的设置；下边是 target 的，包含 <code>General</code>、<code>Capabilities</code>、<code>Resource tags</code>、 <code>Info</code>、<code>Build Settings</code>、<code>Build phases</code>和<code>Build rules</code>七个选项卡，比较复杂，每一项都直接决定了我们最终 App（product）的显示效果。</p>
<p><img src="iOS项目Project和Target配置详解.assets/ProjectAndTargets_03.png" alt="project 属性示意图"></p>
<p><img src="iOS项目Project和Target配置详解.assets/ProjectAndTargets_04.png" alt="target 属性示意图"></p>
<h2 id="Project-属性"><a href="#Project-属性" class="headerlink" title="Project 属性"></a>Project 属性</h2><p>Project 的属性包含<code>Info</code> 和 <code>Build Settings</code> 两个选项卡的内容，但是 target 的<code>Build Settings</code>和 project 的是关联的，会继承部分 project 的<code>Build Settings</code>的属性，这里主要讲解<code>Info</code> ，<code>Build Settings</code>后面与 target 的一起讲解。</p>
<h3 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h3><p><code>Info</code>主要包括三部分内容：<code>Deployment Target</code>、<code>Configurations</code>和 <code>Localizations</code>。 </p>
<h4 id="1-Deployment-Target"><a href="#1-Deployment-Target" class="headerlink" title="1. Deployment Target"></a>1. <code>Deployment Target</code></h4><p>部署配置，主要是本 project 生成的 APP 的可运行的最低版本进行配置，默认是当前 Xcode 上 API 的最新版本。所以，在我们的项目中有需要对低版本适配的地方可以在这里设置。同样的，我们还可以在<code>build setting</code>中对这一属性进行设置，两者是同步的。target 的 <code>General</code>-&gt;<code>Deployment Info</code>-&gt;<code>Deployment Target</code>默认继承此属性，手动修改则覆盖此属性。</p>
<h4 id="2-Configurations"><a href="#2-Configurations" class="headerlink" title="2. Configurations"></a>2. <code>Configurations</code></h4><p>用来配置 iOS 项目的<code>xcconfig</code>文件，主要用于在几套不同的开发环境编译。<code>xcconfig</code>文件其实就是 Xcode 里的<code>config</code>文件，本质是一个用来保存<code>Build Settings</code>键值对的<strong>纯文本文件</strong>。这些键值对会覆盖<code>Build Settings</code>中的值，所以当在<code>xcconfig</code>文件中配置了的选项，在<code>Build Settings</code>中设置将失效。具体使用<a href="https://www.jianshu.com/p/b1b6255ff3ee" target="_blank" rel="external">参照这里</a>。项目中一般不会进行<code>xcconfig</code>文件的自定义。</p>
<p>Cocoapods 的项目配置管理很多都是依赖<code>xcconfig</code>文件去实现的。所以在使用 Cocoapods 进行导包的项目中，我们通过打开.xcworkspace 文件，我们会发现<code>Project</code>—&gt;<code>Info</code>—&gt;<code>Configutations</code>下的都有对应的配置文件，而原先没有用 Cocoapods 配置的则没有相关的配置文件，具体区别如下图所示。</p>
<p><img src="iOS项目Project和Target配置详解.assets/ProjectAndTargets_06.png" alt="ProjectAndTargets_06"></p>
<p><img src="iOS项目Project和Target配置详解.assets/ProjectAndTargets_05.png" alt="ProjectAndTargets_05"></p>
<h4 id="3-Localizations"><a href="#3-Localizations" class="headerlink" title="3. Localizations"></a>3. <code>Localizations</code></h4><p>本地化，这里的功能主要是添加我们的App所支持的语言，通过<code>Localizations</code>选项下面的【+】【-】按钮可以添加或删除不同的语种，并可以选择根据手机的设置进行不同语种的自适应。关于最下面的选择是否开启国际化，默认是开启的，至于如何进行国际化和不同语种的适配详情见：<a href="http://www.cocoachina.com/ios/20151120/14258.html" target="_blank" rel="external">详述iOS国际化</a>。</p>
<h3 id="Build-Settings-1"><a href="#Build-Settings-1" class="headerlink" title="Build Settings"></a>Build Settings</h3><p>与下面 Target 的 <code>Build Settings</code>一起介绍</p>
<h2 id="Target-的属性"><a href="#Target-的属性" class="headerlink" title="Target 的属性"></a>Target 的属性</h2><p>Target 的属性设置的内容比较多，总共有<code>General</code>、<code>Capabilities</code>、<code>Resource tags</code>、<code>Info</code>、<code>Build setting</code>、<code>Build phases</code>和<code>Build rules</code>七个选项卡。</p>
<h3 id="General"><a href="#General" class="headerlink" title="General"></a>General</h3><p><code>General</code>主要包括六部分内容：<code>Identity</code>、<code>Signing、</code> <code>Deployment Info</code>、<code>App Icons and Launch Images</code>、<code>Embedded Binaries</code>和<code>Linked Frameworks and Libraries</code>。 </p>
<h4 id="Identity"><a href="#Identity" class="headerlink" title="Identity"></a><code>Identity</code></h4><p>标识符，栏主要定义了一些和应用发布有关的标识属性</p>
<ul>
<li>Display Name：App 应用显示名字，安装到iOS手机或iPad上App的名称。</li>
<li>Bundle Identifier：包标识符，是该应用唯一的 ID，用来让操作系统和AppStore识别。在创建项目或者对象过程中Xcode 就自行创建了包标识符，一般情况下不要修改它。一般以公司域名倒序+App名称进行命名。</li>
<li>Version：外部版本号，使用户能看到的版本号。</li>
<li>Build：内部版本号，开发者自己看到的版本号，以区分内部测试版本。</li>
</ul>
<h4 id="Signing"><a href="#Signing" class="headerlink" title="Signing"></a><code>Signing</code></h4><p>签名，进行证书管理在真机调试或者打包时都需要进行签名进行认证才可以。</p>
<ul>
<li>Automatically manage signing：Xcode 8推出的自动签名功能，可以直接使用 Xcode 把 App 打包到真机上去测试，<a href="https://blog.csdn.net/java3182/article/details/78885145" target="_blank" rel="external">具体使用参考</a>。</li>
<li>Team：开发团队，即开放者账号名称。</li>
<li>Provisioning Profile：提供的配置文件。</li>
<li>Signing Certificate：签名证书</li>
</ul>
<h4 id="Deployment-Info"><a href="#Deployment-Info" class="headerlink" title="Deployment Info"></a><code>Deployment Info</code></h4><p>部署信息，定义了一些和应用配置相关的标识属性</p>
<ul>
<li>Deployment Target：部署对象，用来设置支持的最低版本。这个和 project 的<code>info</code>中的一个意思，并且，这两个的设置最好是一样，如果不一样，最后的App会以target的设置为准。</li>
<li>Devices：设备，设置支持的设备，有iPhone、iPad和Universal（通用）三个选项。</li>
<li><p>Main Interface：主界面，应用启动时预加载的主界面视图。一般有两种方法：</p>
<ol>
<li>一种是通过 Main.storyboard 进行启动，设置这种方法需要我们整个项目的逻辑和跳转都在 Main.storyboard 中完成</li>
<li>取消<code>stroryboard</code>的方式启动主界面，而是通过代码的方式运行main.m的方法进行启动，并通过在AppDelegate的 - (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions 方法中指定主界面视图进行启动。<strong>一般项目中都是采用这种方法进行的，因为一般项目中界面比较多，很多都是通过纯代码的风格进行定义的，这样方便修改和定位问题，项目的逻辑也更清晰，特别是多人合作的项目，这种风格更适合</strong></li>
</ol>
</li>
<li><p>Device Orientation：设备方向，定义应用支持的方向。有Portrait（正向）、Upside Down（倒置）、Landscape Left（横评、Home键在左）、Landscape Right（横评、Home键在右）四种方向。</p>
</li>
<li>Status Bar Style：状态栏状态，设置 App 启动时状态栏的状态，可设置为 Default（默认黑色）、Light（白色）。还可以设置是否隐藏，是否要全屏启动。尽在 App 启动时有效，启动完成后效果过期。</li>
</ul>
<h4 id="App-Icons-and-Launch-Images"><a href="#App-Icons-and-Launch-Images" class="headerlink" title="App Icons and Launch Images"></a><code>App Icons and Launch Images</code></h4><p>应用图标和启动页面。主要设置三项：应用图标、启动图片和启动页面。具体应用图标和启动页面的大小尺寸介绍见官网：<a href="https://developer.apple.com/ios/human-interface-guidelines/icons-and-images/app-icon/" target="_blank" rel="external"><strong>Human Interface Guidelines</strong></a>。</p>
<ul>
<li>App Icons Source：应用图标，对应着文件资源 Assets.xcassets 目录中的 AppIcon 中的图片。最右边的面板可以选择添加哪一种或哪几种设备上的图标，每一个型号的设备上的图标的尺寸是不同的。在中间有一个个的小格子，我们将所有切好的图标直接拖过来，他们会自动找到自己应该放在的格子里。这些小格子主要分为四类：<ol>
<li>Notification：通知时的图标，类似有应用相关的推送消息时，有时候需要显示本应用的图标则会显示这个尺寸的</li>
<li>Spotlight：搜索小图标，当在Spotlight中输入应用名，搜索结果中出现该应用时的图标就是这个尺寸的，还有设置里的图标也是这个尺寸的。</li>
<li>App：这就是正常的App图标，安装好之后在桌面显示的，或者分享推荐时显示的应用也是这个尺寸的图标</li>
<li>App store：应用商店中的显示的图标</li>
</ol>
</li>
</ul>
<p><img src="iOS项目Project和Target配置详解.assets/ProjectAndTargets_08.png" alt="ProjectAndTargets_08"></p>
<ul>
<li>Luanch Image Source：启动图片，同样对应着文件资源Assets.xcassets目录中的LuanchImage中的图片，设定了各种情况下的启动图片，和 Appicon 一样，我们将所有切好的图标直接拖过来，他们会自动找到自己应该放在的格子里。<strong>启动图片实际上定义了应用启动后的界面大小</strong>，所以在不同机型中我们需要做好适配，见下面的【启动页面在屏幕适配中的作用】。一款App必须设定对应设备的启动图片，否则点开应用会是一片黑色。</li>
<li>Luanch Screen File：启动页面文件，是一个storyboard文件，作用与 Luanch Image 一样，但是启动文件的优先级高于启动图片，就是说如果两个都设置了，那么启动页面以启动文件为准，如果都没有设置，则启动时是一片黑色。<ul>
<li>启动页面的作用：在我们点击应用图标启动应用时，应用启动需要一定的操作时间，再启动期间，为了增强应用程序启动时的用户体验，您应该提供一个启动图像。启动图像与应用程序的首屏幕看起来非常相似。当用户在主屏幕上点击您的应用程序图标时，iPhone OS会立即显示这个启动图像。一旦准备就绪，您的应用程序就会显示它的首屏幕，来替换掉这个启动占位图像。一定要强调的是，之所以提供启动图像，是为了改善用户体验，并不是为了提供：应用程序进入体验，比如启动动画。</li>
<li>启动页面在屏幕适配中的作用：每个机型，比如同时支持 iPhone 和 iPad的 程序，需要分别为 iPhone 跟 iPad 指定启动图片。当旧的 iPhone 4 的程序，运行在 iPhone 5 上面，没有iPhone 5的启动图片，就采用兼容模式，上下留黑边。当为 iPhone 5 指定了新的启动图片，系统就认为这个应用程序是已经适配了iPhone 5的。当旧的iPhone 5程序运行在iPhone 6上面，假如没有经过适配。旧程序自动等比放大，铺满新手机，旧程序也可以正常运行。这种方案可算是自动适配。但因为旧程序拉伸了，整体看起来有点虚，也不能更好利用大屏空间。当需要开发者手动适配的时候，跟iPhone 4过渡到iPhone 5一样，在新程序中，指定一张新的启动图片。当指定了启动图，系统就认为应用已经做好了屏幕适配，屏幕分辨率就变成应有的大小。在某机型上，<strong>如果是自动适配，比如iPhone 5，老版程序就会在屏幕上、下俩端多出俩块黑条；比如iPhone6/6plus，老版程序就会自动等比拉伸</strong>。那如何关闭自动适配？指定启动图或者使用Launch Screen File.xib，即程序使用手动适配，不会做拉伸等，但是程序内部必须已做处理，否则使用自动适配方案。</li>
</ul>
</li>
</ul>
<h4 id="Embedded-Binaries"><a href="#Embedded-Binaries" class="headerlink" title="Embedded Binaries"></a><code>Embedded Binaries</code></h4><p>绑定二进制文件，用来连接二进制文件，一般在使用第三方SDK的时候使用。</p>
<h4 id="Linked-Frameworks-and-Libraries"><a href="#Linked-Frameworks-and-Libraries" class="headerlink" title="Linked Frameworks and Libraries"></a><code>Linked Frameworks and Libraries</code></h4><p>链接的框架和库，选择要链接的框架和库，既可以是SDK自带的框架，也可以是第三方框架，在 Build Phases 中也有相同的功能选项。</p>
<h3 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h3><p>target 的 Capabilities 属性设置这一块主要是一些性能设置开关选择，例如推送通知、云存储、游戏中心、后台模式等，我们选择需要的开关进行打开或者关闭，这些相应的状态都会在 info.plist 中进行修改。所以，同样的，我们也可以在info.plist添加一些权限或性能开关之后，在target的capabilities中也会进行相应的修改的。</p>
<h3 id="Resource-Tag"><a href="#Resource-Tag" class="headerlink" title="Resource Tag"></a>Resource Tag</h3><p>Target 中的 Resource Tag 选项卡主要是为项目中的资源进行添加 tag 分类。方便我们对其加载顺序和加载时机进行选择和设置，即实现按需加载，在需要的时候才加载资源。按需加载资源是由App Store托管的内容，它和下载的 App bundle是分开的。App请求一系列按需加载资源，而下载和存储资源是由操作系统来管理。这些资源可以是除可执行代码外，bundle 支持的任何类型。这样做的好处就是可以实现如下几种资源加载形式：</p>
<ul>
<li><strong>初始资源的延迟加载。</strong>app有一些资源是主要功能要用到的，但在启动时并不需要。将这些资源标记为“初始需要”。操作系统在app启动时会自动下载这些资源。例如，图片编辑app有许多不常用的滤镜。</li>
<li><strong>app资源的延迟加载。</strong>app有一些只在特定情景下使用的资源，当应用可能要进入这些场景时，会请求这些资源。例如，在一个有很多关卡的游戏中，用户只需要当前关卡和下一关卡的资源。 </li>
<li><strong>不常用资源的远程存储。</strong>app有一些很少使用的资源，当需要这些资源时会去请求它们。例如，当app第一次打开时会展示一个教程，而这个教程之后就可能不会在用到。app在第一次启动时请求教程的资源，这之后只在需要展示教程或者添加了新功能才去请求该资源。</li>
<li><strong>应用内购买资源的远程存储。</strong>app提供包含额外资源的应用内购买。app会在启动完成后请求已购买模块的资源。例如，用户在一个键盘app内购买了SuperGeeky表情包。应用程序会在启动完成后请求表情包的资源。</li>
</ul>
<p><img src="iOS项目Project和Target配置详解.assets/1434337166834154.png" alt="18.png"></p>
<p>在 Resource Tags 选项卡的 Prefetched 界面下，可以把 tag 分配给三个预获取优先级分类的其中一个。界面展示了按预获取分类分组的 tag。tag 可以在分类间拖动。</p>
<ul>
<li><strong>初始安装tag（Initial install tags）</strong>。只有在初始安装tag下载到设备后，app才能启动。这些资源会在下载app时一起下载。这部分资源的大小会包括在App Store中app的安装包大小。如果这些资源从来没有被NSBundleResourceRequest 对象获取过，就有可能被清理掉。</li>
<li><strong>按顺序预获取tag（Prefetch tag order）</strong>。在app安装后会开始下载tag。tag会按照此处指定的顺序来下载。 </li>
<li><strong>按需下载（Dowloaded only on demand）</strong>。当app请求一个tag，且tag没有缓存时，才会下载该tag。</li>
</ul>
<p>关于Resource Tag和按需加载的详情内容和步骤参见下面两篇文章：</p>
<ul>
<li><a href="http://www.cocoachina.com/ios/20150615/12155.html" target="_blank" rel="external">On-Demand Resources Guide中文版（按需加载资源–上）</a></li>
<li><a href="http://www.cocoachina.com/ios/20150615/12152.html" target="_blank" rel="external">On-Demand Resources Guide中文版（按需加载资源—下）</a></li>
</ul>
<h3 id="Info-1"><a href="#Info-1" class="headerlink" title="Info"></a>Info</h3><p>Target 的 Info 属性设置界面如下图所示，主要分为五个部分<code>Custom iOS Target Properties</code>、<code>Docunment Types</code>、<code>Exported UTIs</code>、<code>Imported UTIs</code>、<code>URL types</code>。</p>
<p><img src="iOS项目Project和Target配置详解.assets/926487-20180121192046818-1861518679.png" alt="img"></p>
<h4 id="Custom-iOS-Target-Properties"><a href="#Custom-iOS-Target-Properties" class="headerlink" title="Custom iOS Target Properties"></a><code>Custom iOS Target Properties</code></h4><p>自定义 iOS 属性，Target 的 Info 属性里最重要的一项。在 target 的 Info 选项卡中的此项信息与我们项目资源目录下的 info.plist 文件中的内容是一致，并且修改其中一个另一个会自动修改。此外，<code>General</code> 选项卡中的一些设置也会对应到 info.plist 文件中，所以这些内容都是相通的，我们修改一处，其他的地方会同步修改。info.plist 中其实加载的信息会非常多，上面是创建项目之后自动生成的一些最基本的设置选项，每一项对应的意思如下解释：</p>
<ul>
<li>Localization native development region ： 与本地化设置有关，为默认的开发语言</li>
<li>Executable file：程序安装包的名称</li>
<li>Bundle identifier：软件唯一的标识，是根据公司的标识与项目名称自动生成的，在上传和测试的时候会用到</li>
<li>InfoDictionary version：版本信息</li>
<li>Bundle name：App安装后显示的名称</li>
<li>Bundle OS Type code：用来标识软件包类型</li>
<li>Bundle versions string, short：发布的版本字符串</li>
<li>Bundle creator OS Type code：创建者的标识</li>
<li>Bundle version：应用程序版本号</li>
<li>Application requires iPhone environment：用于指示程序包是否只能运行在iPhone OS 系统上，默认为YES</li>
<li>Launch screen interface file base name：欢迎界面的文件名称</li>
<li>Main storyboard file base name：默认情况下程序的主入口</li>
<li>Supported interface orientations：设置程序默认支持的方向</li>
</ul>
<p>除此之外，我们在开发过程可能还需要添加一些其他的信息，包括一些权限的添加，网络权限、定位权限、读写联系人权限等等，应用白名单的添加等都是在这里进行配置的。关于 info.plist 的具体信息和内容详情参见：<a href="http://www.cocoachina.com/ios/20160922/17611.html" target="_blank" rel="external"><strong>Xcode中的Info.plist字段列表详解</strong></a>。</p>
<h4 id="Document-Types"><a href="#Document-Types" class="headerlink" title="Document Types"></a><code>Document Types</code></h4><p>文档类型，定义了应用程序所能识别的文档类型，并且还可以定义在系统中显示的该类型文档的自定义图标。</p>
<h4 id="Exported-UTIs"><a href="#Exported-UTIs" class="headerlink" title="Exported UTIs"></a><code>Exported UTIs</code></h4><p>导出的UTI，UTI Uniform Type Identifiers —— 同一类型标识符。</p>
<h4 id="Imported-UTIs"><a href="#Imported-UTIs" class="headerlink" title="Imported UTIs"></a><code>Imported UTIs</code></h4><p>导入的UTI</p>
<h4 id="URL-Types"><a href="#URL-Types" class="headerlink" title="URL Types"></a><code>URL Types</code></h4><p>URL类型，用来定义URL以便让应用程序理解应用间交换的数据结构。可用于：IOS唤醒其他程序，程序间相互调用。例如：在 URLTypes 中 URLSchemes 中注册 AAPP；在B程序中，openUrl:[NSURL urlWithString:@”AAPP:”]；注意”:”冒号,没有冒号是不能成唤醒另一个程序的。其次如果参数中有“&amp;”特殊字符穿，建议对参数进行 base64 转换。</p>
<h3 id="Build-Settings-2"><a href="#Build-Settings-2" class="headerlink" title="Build Settings"></a>Build Settings</h3><p>target 的 Build Settings 选项卡是最主要的一部分编译选项设置，配置界面如下图所示，完整的 Build Settings 共有将近40项配置内容。从配置界面上看，每一项的配置都有四列（如果使用pod，还会增加一列），可以看到，从左至右的顺序分别是：Resolved 列、带 Target 图标列、带 Project 图标列、iOS Default 列，每一列所代表的意义如下。</p>
<p><img src="iOS项目Project和Target配置详解.assets/3FBCE6D5-218B-44D9-9944-79D3D23D9980.png" alt="3FBCE6D5-218B-44D9-9944-79D3D23D9980"></p>
<ul>
<li><strong>Resolved 列</strong>：<strong>最终确定的编译方式，无法自己设定</strong>。其结果是根据其右边三栏的选择结果以及优先级顺序来确定最后编译时采用的编译方式。在图的第二行选项卡中选择<code>combined</code>选项，可以直接地看到只有该栏的最后结果。</li>
<li><strong>带 Target 图标列</strong>：<strong>target 的 Build Settings 配置的编译选项，可自定义</strong>。其优先级最高，一旦进行设置，则最后的编译方式以该栏的结果为准。</li>
<li><strong>带 Project 图标列</strong>：<strong>project 的 Build Settings 配置的编译选项，可自定义</strong>，这一栏的结果与 project 中 build setting 选项卡中的结果是一致的，修改其中一个地方，另一处也会自动修改。其优先级介于 target 和 default 之间，当 target 没有设置编译选项，而该栏进行了设置时，则最后的编译方式以该栏为准。 </li>
<li><strong>iOS Default 列</strong>：<strong>在创建项目时系统自带的默认编译选项，无法修改</strong>。优先级最低，只有当其他两栏都没有设置选项时，最后的编译方式才会以该栏为准。</li>
</ul>
<p><strong>优先级顺序：带 Target 图标列 &gt;&gt; 带 Project 图标列 &gt;&gt; iOS Default 列</strong>。（如果安装pod，新产生的一列优先级介于带 Target 图标列和带 Project 图标列之间）</p>
<p><a href="http://www.360doc.com/content/14/1217/07/19175681_433531035.shtml" target="_blank" rel="external"><strong>Xcode 编译选项详解</strong></a>。</p>
<h3 id="Build-phases"><a href="#Build-phases" class="headerlink" title="Build phases"></a>Build phases</h3><p>Target 的 build phases 选项卡的的主要功能是配置编译器在不同编译阶段的参数，包括编译所需的资源文件（包括代码、配置以及各种资源文件），配置界面如下图所示，主要包括四方面的内容。</p>
<p><img src="iOS项目Project和Target配置详解.assets/C90783E8-1A9E-4C5E-8787-54753BFBE122.png" alt="C90783E8-1A9E-4C5E-8787-54753BFBE122"></p>
<h4 id="Target-Dependencies"><a href="#Target-Dependencies" class="headerlink" title="Target Dependencies"></a><code>Target Dependencies</code></h4><p>Target 对象依赖阶段：某些 target 可能依赖某个 target 输出的值，这里设置依赖。依赖于其他 target 的输出的时候，在编译时系统会自动先编译被依赖的 target，得到输出值，再编译当前 target。对象依赖阶段可以让 Xcode 知道必须在当前选择的对象编译之前先编译的其它依赖对象（比如应用扩展、插件等等）。如单元测试 target，依赖于 App target，所以必须等 App target 编译完成之后再进行编译。</p>
<h4 id="Compile-Sources"><a href="#Compile-Sources" class="headerlink" title="Compile Sources"></a><code>Compile Sources</code></h4><p>源文件阶段：是指将有哪些源代码被编译，可以通过对应的【+】【-】按钮进行添加或删除资源来控制编译的代码文件。并且可以通过修改此阶段的 Compiler Flags（编译器标识）来为每个单独文件设置其编译器标示，比如设置是否支持ARC。</p>
<h4 id="Link-Binary-With-Libraries"><a href="#Link-Binary-With-Libraries" class="headerlink" title="Link Binary With Libraries"></a><code>Link Binary With Libraries</code></h4><p>链接二进制库阶段：是指编译过程中会引用哪些库文件，我们同样可以通过【+】【-】按钮进行添加或删除编译所引用的库文件。</p>
<h4 id="Copy-Bundle-Resources"><a href="#Copy-Bundle-Resources" class="headerlink" title="Copy Bundle Resources"></a><code>Copy Bundle Resources</code></h4><p>拷贝 Bundle 资源阶段：是指生成的 product 的 .app 内将包含哪些资源文件，同样可以通过红框中的【+】【-】按钮进行添加或删除资源来控制编译的资源文件。该阶段定义了对象中的资源文件，包括应用程序、图标、storyboard、视频、模板等等。这些资源都会被复制到安装包的 Contents／Resources 文件夹下。</p>
<h3 id="Build-Rules"><a href="#Build-Rules" class="headerlink" title="Build Rules"></a>Build Rules</h3><p>Build rules 指定了不同文件类型该如何编译。一般来说，开发者并不需要修改这里面的内容。</p>
<p>如果需要对特定的文件类型添加处理方法，那么可以在此处添加一条新的规则。一条 build rule 指定了其应用于哪种文件类型，该文件类型是如何被处理的，以及输出内容被放置到何处。比方说，我们创建了一条预处理规则，该规则将Objective-C的实现文件当做输入，然后解析文件内部的注释内容，最后再输出一个.m文件，文件中包含了生成的代码。由于不能将 .m 文件既当做输入又当做输出，所以使用了.mal 后缀，定制的 build rule 如下所示：</p>
<p><img src="iOS项目Project和Target配置详解.assets/48118764_5-6911734.png" alt="48118764_5-6911734"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[const/static/extern的使用]]></title>
      <url>http://www.liugangqiang.com/2017/05/19/const-static-extern%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="const-与宏的区别"><a href="#const-与宏的区别" class="headerlink" title="const 与宏的区别"></a>const 与宏的区别</h2><ul>
<li><code>编译时刻</code>:宏是预编译（编译之前处理），const是编译阶段。</li>
<li><code>编译检查</code>:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。</li>
<li><code>宏的好处</code>:宏能定义一些函数，方法。 const不能。</li>
<li><code>宏的坏处</code>:使用大量宏，容易造成编译时间久，每次都需要重新替换。</li>
</ul>
<blockquote>
<p>   注意：使用宏，并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见的常量，使用宏替换</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GGAccount @<span class="string">"accunt"</span></span></span><br><span class="line"><span class="comment">// 字符串常量</span></span><br><span class="line"><span class="keyword">static</span> NSString * <span class="keyword">const</span> account = @<span class="string">"accunt"</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSString *acc = GGAccount;</span><br><span class="line">    NSLog(@<span class="string">"acc:    %p---%p---%@"</span>, acc, &amp;acc, acc.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"account:%p---%p---%@"</span>, account, &amp;account, account.<span class="keyword">class</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">acc:    <span class="number">0x1084f9078</span>--<span class="number">-0x7ffee7705fe8</span>---__NSCFConstantString</span><br><span class="line">account:<span class="number">0x1084f9078</span>--<span class="number">-0x1084f9070</span>---__NSCFConstantString</span><br><span class="line"><span class="comment">// 变量 acc 和常量 account 指向的是同一块内存区域，即字符串常量 @"accunt" 所在的内存地址</span></span><br><span class="line"><span class="comment">// account 被 const 修饰，所以是常量，内存在常量区</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="const-作用：限制类型"><a href="#const-作用：限制类型" class="headerlink" title="const 作用：限制类型"></a>const 作用：限制类型</h2><ul>
<li><code>const</code>仅仅用来修饰右边的变量（基本数据变量p，指针变量*p）</li>
<li>被<code>const</code>修饰的变量是只读的。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; 		<span class="comment">// 定义变量</span></span><br><span class="line">a = <span class="number">100</span>;    		<span class="comment">// 允许修改值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b的值不允许修改，这两种写法作用相同</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// b = 10;			// 不允许修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const:修饰指针变量*p，带*的变量，就是指针变量.</span></span><br><span class="line"><span class="comment">// 定义一个 const 修饰的指针变量，const修饰的是 *p，即 p 访问的内存空间</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a; </span><br><span class="line"><span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">p = &amp;c;			   <span class="comment">// 允许修改 p 的值，即所指向的地址</span></span><br><span class="line"><span class="comment">// *p = 20;		   // 不允许修改 p 访问的内存空间的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const:修饰指针变量 p1</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p1 = &amp;a; <span class="comment">// const修饰的是 p，即 p 自身的内存空间</span></span><br><span class="line"><span class="comment">// p1 = &amp;c;			 // 不允许修改 p 的值，即所指向的地址</span></span><br><span class="line">*p1 = <span class="number">30</span>;			 <span class="comment">// 可以修改 p 访问的内存空间的值</span></span><br></pre></td></tr></table></figure>
<h2 id="static-作用"><a href="#static-作用" class="headerlink" title="static 作用"></a>static 作用</h2><ul>
<li>修饰局部变量：<ol>
<li>延长局部变量的生命周期，程序结束才会销毁。</li>
<li>局部变量只会生成一份内存，只会初始化一次。</li>
<li>改变局部变量的作用域。</li>
</ol>
</li>
<li>修饰全局变量<ol>
<li>只能在本文件中访问，修改全局变量的作用域，生命周期不会改</li>
<li>避免多个同名全局变量重复定义引发冲突</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static 修饰全局变量，只能在本文件中访问，生命周期不会改</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static 修饰局部变量</span></span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">        age++;</span><br><span class="line">        NSLog(@<span class="string">"%d----%p"</span>,age, &amp;age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果，可以看出 age 只初始化了一次，存在一份内存，每次循环使用的都是同一个变量</span></span><br><span class="line"><span class="number">1</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">2</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">3</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">4</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">5</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">6</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">7</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">8</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">9</span>---<span class="number">-0x1018e3f80</span></span><br><span class="line"><span class="number">10</span>---<span class="number">-0x1018e3f80</span></span><br></pre></td></tr></table></figure>
<h2 id="extern-作用"><a href="#extern-作用" class="headerlink" title="extern 作用"></a>extern 作用</h2><ul>
<li><p>只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量</p>
</li>
<li><p>先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个 .m 文件定义一个全局变量</span></span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个文件中，使用 extern 可以访问到这个变量</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">     [super viewDidLoad];</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">extern</span> <span class="keyword">int</span> p;</span><br><span class="line">     NSLog(@<span class="string">"%d"</span>,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="static-与-const-组合使用"><a href="#static-与-const-组合使用" class="headerlink" title="static 与 const 组合使用"></a>static 与 const 组合使用</h2><ul>
<li><p>作用：<code>static</code>与<code>const</code>组合可声明一个只读的静态变量</p>
</li>
<li><p>使用场景：在<code>一个文件中</code>经常使用的字符串常量，定义成静态全局只读变量，可以使用<code>static</code>与<code>const</code>组合。如：Cell 的 ReuseIdentifier </p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开发中常用 static 修饰全局变量，只改变作用域，防止重复声明全局变量</span></span><br><span class="line"><span class="comment">// 开发中声明的全局变量，有些不希望外界改动，只允许读取。</span></span><br><span class="line"><span class="comment">// 比如一个基本数据类型不希望别人改动</span></span><br><span class="line"><span class="comment">// 声明一个静态的全局只读常量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开发中经常拿到 key 修改值，因此用 const 修饰 key，表示 key 只读，不允许修改。</span></span><br><span class="line"><span class="keyword">static</span> NSString * <span class="keyword">const</span> key = @<span class="string">"name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cell 的重用字符串，每次获取 cell 时都会使用，创建一个静态常量，避免反复创建</span></span><br><span class="line"><span class="keyword">static</span> NSString * <span class="keyword">const</span> cellIdentifier = @<span class="string">"cellIdentifier"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="extern-与-const-组合使用"><a href="#extern-与-const-组合使用" class="headerlink" title="extern 与 const 组合使用"></a>extern 与 const 组合使用</h2><ul>
<li><p>作用：<code>extern</code>与<code>const</code>组合，只需要定义一份全局变量，多个文件共享。</p>
</li>
<li><p>使用场景：在<code>多个文件中</code>经常使用的同一个字符串常量，可以使用<code>extern</code>与<code>const</code>组合</p>
</li>
<li><p>全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个<code>GlobeConst</code>文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">extern</span> NSString * <span class="keyword">const</span> nameKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line">NSString * <span class="keyword">const</span> nameKey = @<span class="string">"name"</span>;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS内存分布]]></title>
      <url>http://www.liugangqiang.com/2017/05/18/iOS%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</url>
      <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p><strong>随机存取存储器</strong>（random access memory，RAM）又称作“<a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8" target="_blank" rel="external">随机存储器</a>”，是与CPU直接交换数据的内部存储器，也叫主存(内存)。</p>
<ul>
<li>存储单元的内容可按需随意取出或存入，且存取的速度很快，与存储单元的位置无关。</li>
<li>这种存储器在断电时将丢失其存储内容，故主要用于存储 <em>短时间使用</em> 的程序。</li>
<li>通常作为操作系统或其他正在运行中的程序的临时数据存储媒介。</li>
</ul>
<h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>ROM是<a href="https://baike.baidu.com/item/%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8" target="_blank" rel="external">只读存储器</a>（Read-Only Memory）的简称，是一种只能读出事先所存数据的固态半导体存储器。</p>
<ul>
<li>所存数据稳定，断电后所存数据也不会改变。</li>
<li>其结构较简单，读出较方便，因而常用于存储各种固定程序和数据。</li>
<li>为便于使用和大批量生产，进一步发展了各种可读写存储器，如快闪存储器(Flash memory)。</li>
</ul>
<p>在计算机系统运行应用时，会把APP从ROM里面拷贝到内存（RAM），然后从内存里面执行代码。运行的应用程序的数据都是保存在内存中的，不同类型的数据，保存的内存区域不同。</p>
<a id="more"></a>
<h1 id="iOS的内存"><a href="#iOS的内存" class="headerlink" title="iOS的内存"></a>iOS的内存</h1><p>iOS的内存分布与C语言的类似，分为：</p>
<ol>
<li>代码区</li>
<li>文字常量区</li>
<li>全局区/静态区(Static）</li>
<li>堆区(Heap)</li>
<li>栈区(Stack)</li>
</ol>
<h2 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h2><p>存放函数的二进制代码</p>
<h2 id="常量区"><a href="#常量区" class="headerlink" title="常量区"></a>常量区</h2><p>存放常量字符串以及其他定义的常量，程序结束系统释放</p>
<h2 id="全局区-静态区-Static）"><a href="#全局区-静态区-Static）" class="headerlink" title="全局区/静态区(Static）"></a>全局区/静态区(Static）</h2><p>全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后由系统释放。</p>
<blockquote>
<p>注意：全局区又可分为：</p>
<p>未初始化全局区： bss段</p>
<p>初始化全局区：data段</p>
<p>举例：int a——未初始化的；int a = 10——已初始化的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p;    <span class="comment">// 全局未初始化区</span></span><br></pre></td></tr></table></figure>
<h2 id="堆区-Heap"><a href="#堆区-Heap" class="headerlink" title="堆区(Heap)"></a>堆区(Heap)</h2><ul>
<li>堆区的内存分配使用的是alloc，代码中创建的对象一般都存在堆中</li>
<li>需要程序猿管理内存；</li>
<li>ARC的内存的管理，是编译器再便宜的时候自动添加 retain、release、autorelease；</li>
<li>堆区的地址是从低到高分配）</li>
</ul>
<h2 id="栈区-Stack"><a href="#栈区-Stack" class="headerlink" title="栈区(Stack)"></a>栈区(Stack)</h2><ul>
<li>存放的局部变量、先进后出、一旦出了作用域就会被销毁；函数跳转地址，现场保护等；</li>
<li>程序猿不需要管理栈区变量的内存；</li>
<li>栈区地址从高到低分配；   </li>
</ul>
<p><img src="/uploads/iOSMemoryLayout/iOSMemoryLayout-image.png" alt=""></p>
<h1 id="具体代码分析"><a href="#具体代码分析" class="headerlink" title="具体代码分析"></a>具体代码分析</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别创建相同的全局变量</span></span><br><span class="line"></span><br><span class="line">NSInteger a = <span class="number">100</span>;</span><br><span class="line">NSString *str1 = @<span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">const</span> NSString *str2 = @<span class="string">"123"</span>;</span><br><span class="line">NSString *strEm1 = @<span class="string">""</span>;</span><br><span class="line">NSString *strEm2 = @<span class="string">""</span>;</span><br><span class="line">NSInteger b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSString *str3 = @<span class="string">"123"</span>;</span><br><span class="line">    NSString *strEm3 = @<span class="string">""</span>;</span><br><span class="line">    NSMutableString *mutStr = [[NSMutableString alloc] init];</span><br><span class="line">    NSString *strEm4 = [NSString <span class="built_in">string</span>];</span><br><span class="line">    NSString *strEm5 = [[NSString alloc] init];</span><br><span class="line">    NSLog(@<span class="string">"str1:  %p---%p---%@"</span>, str1, &amp;str1, str1.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"str2:  %p---%p---%@"</span>, str2, &amp;str2, str2.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"str3:  %p---%p---%@"</span>, str3, &amp;str3, str3.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"strEm1:%p---%p---%@"</span>, strEm1, &amp;strEm1, strEm1.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"strEm2:%p---%p---%@"</span>, strEm2, &amp;strEm2, strEm2.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"strEm3:%p---%p---%@"</span>, strEm3, &amp;strEm3, strEm3.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"strEm4:%p---%p---%@"</span>, strEm4, &amp;strEm4, strEm4.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"strEm5:%p---%p---%@"</span>, strEm5, &amp;strEm5, strEm5.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"mutStr:%p---%p---%@"</span>, mutStr, &amp;mutStr, mutStr.<span class="keyword">class</span>);</span><br><span class="line">    NSLog(@<span class="string">"a:     %p"</span>, &amp;a);</span><br><span class="line">    NSLog(@<span class="string">"b:     %p"</span>, &amp;b);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">str1:  <span class="number">0x10e117070</span>--<span class="number">-0x10e118048</span>---__NSCFConstantString</span><br><span class="line">str2:  <span class="number">0x10e117070</span>--<span class="number">-0x10e118050</span>---__NSCFConstantString</span><br><span class="line">str3:  <span class="number">0x10e117070</span>--<span class="number">-0x7ffee1ae7fe8</span>---__NSCFConstantString</span><br><span class="line">    </span><br><span class="line">strEm1:<span class="number">0x10e117090</span>--<span class="number">-0x10e118058</span>---__NSCFConstantString</span><br><span class="line">strEm2:<span class="number">0x10e117090</span>--<span class="number">-0x10e118060</span>---__NSCFConstantString</span><br><span class="line">strEm3:<span class="number">0x10e117090</span>--<span class="number">-0x7ffee1ae7fe0</span>---__NSCFConstantString</span><br><span class="line">    </span><br><span class="line">strEm4:<span class="number">0x10e713338</span>--<span class="number">-0x7ffee1ae7fd0</span>---__NSCFConstantString</span><br><span class="line">strEm5:<span class="number">0x10e713338</span>--<span class="number">-0x7ffee1ae7fc8</span>---__NSCFConstantString</span><br><span class="line">mutStr:<span class="number">0x60400025caa0</span>--<span class="number">-0x7ffee1ae7fd8</span>---__NSCFString</span><br><span class="line">a:     <span class="number">0x10e118040</span></span><br><span class="line">b:     <span class="number">0x10e118068</span></span><br></pre></td></tr></table></figure>
<p>由此可以看出：</p>
<ol>
<li><p>直接以<code>@&quot;</code>创建的字符串对象都存储在字符串常量区，而且相同的字符串只会在内存中存在一份。其他用到此字符串的变量/常量指针指向这块内存。</p>
</li>
<li><p>全局变量储存在全局区，如 <code>a</code>，<code>b</code>，<code>str1</code>，<code>str2</code>，<code>strEm1</code>，<code>strEm2</code>，其中<code>str1</code>，<code>str2</code>，<code>strEm1</code>，<code>strEm2</code>是指针，指向的字符串常量对象在常量区。</p>
</li>
<li><p><code>str3</code>，<code>strEm3</code>是局部变量，内存在栈区，指向的字符串常量对象在常量区。</p>
</li>
<li><p><code>strEm4</code>，<code>strEm5</code>也是局部变量，内存在栈区，但是其指向的对象是用类创建的空字符串（类型<code>__NSCFConstantString</code>），是预先创建好的，存储在全局区。</p>
</li>
<li><p><code>mutStr</code>可变字符串指针，内存在栈区；指向的可变字符串对象在堆区。一般创建的对象都存储在堆区，指针变量指向这些对象，局部变量本身的内存在栈区。</p>
</li>
<li><p><code>@&quot;123&quot;</code>本身就是常量，所以 <code>str2</code>之前的 <code>const</code>的写与不写没什么区别。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C语言的内存分布]]></title>
      <url>http://www.liugangqiang.com/2017/05/09/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</url>
      <content type="html"><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>经典的 C 语言内存分布包括以下 5 个部分:</p>
<ol>
<li>代码段 (Text segment)</li>
<li>初始化数据段 (Initialized data segment)</li>
<li>未初始化数据段 (Uninitialized data segment)</li>
<li>堆区 (Heap)</li>
<li>栈区 (Stack)</li>
</ol>
<a id="more"></a>
<p><img src="/uploads/memoryLayoutC.jpg" alt=""></p>
<p><img src="/uploads/memoryLayoutD.png" alt=""></p>
<p>这是 C 语言程序运行中的经典内存布局，从低地址区域到高以此排布是：代码段、初始化数据段、未初始化数据段、堆、栈。</p>
<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>代码段 (Text segment)，又叫做文本段。存放 CPU 执行的机器指令 (machine instructions)。</p>
<ul>
<li>通常，代码区是可以共享的（另外的执行程序可以调用它），因为对于频繁操作被执行的的程序，只需要在内存中有一份代码即可。</li>
<li>代码区通常是只读的，防止程序意外的修改了它的指令。</li>
<li>代码区在低地址区域，以防止堆或者栈的溢出</li>
</ul>
<h2 id="初始化数据段"><a href="#初始化数据段" class="headerlink" title="初始化数据段"></a>初始化数据段</h2><p>初始化数据段 (Initialized data segment) 是程序的虚拟地址空间的一部分，它包含由程序员初始化的全局变量和静态变量。</p>
<ul>
<li>数据区不是只读的，因为变量的值可以在运行时改变</li>
<li>该区可进一步分为初始化只读区和初始化读写区</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个在任何函数外的全局变量，存储在初始化读写区域中</span></span><br><span class="line"><span class="keyword">int</span> maxCount = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个静态数据</span></span><br><span class="line"><span class="comment">// 字符文本 “hello world” 存储在初始化只读区域中</span></span><br><span class="line"><span class="comment">// 指针变量 string 存储在在初始化读写区域中</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span> = “hello world”;</span><br></pre></td></tr></table></figure>
<h2 id="未初始化数据段"><a href="#未初始化数据段" class="headerlink" title="未初始化数据段"></a>未初始化数据段</h2><p>未初始化数据段 (Uninitialized data segment)，亦称BSS区，BSS这个叫法是根据一个早期的汇编运算符而来，这个汇编运算符标志着一个块的开始。</p>
<ul>
<li>BSS区从初始化数据区的末尾开始，包含所有全局变量和静态变量，这些变量初始化为零或源代码中没有显式初始化</li>
<li>BSS区的数据在程序开始执行之前被内核初始化为 0 或者空指针（NULL）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个变量都会被存储在未初始化数据区</span></span><br><span class="line"><span class="keyword">long</span> sum[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i；</span><br></pre></td></tr></table></figure>
<h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><p>栈区（stack）。由编译器自动分配释放，存放函数的参数值、局部变量的值、函数的返回值等。</p>
<ul>
<li>其操作方式类似于数据结构中的栈。</li>
<li>除了存储局部变量的值外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。</li>
<li>由于栈的先进先出特点，所以栈特别方便用来保存/ 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li>
</ul>
<h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p>堆 (heap) 是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。</p>
<ul>
<li>一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 </li>
<li>当进程调用<code>malloc</code>等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）</li>
<li>当利用<code>free</code>等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</li>
<li>在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并将在内存中为这些段分配空间。栈段亦由操作系统分配和管理，而不需要程序员显示地管理；堆段由程序员自己管理，即显式地申请和释放空间。</li>
</ul>
<h2 id="堆区和栈区的区别"><a href="#堆区和栈区的区别" class="headerlink" title="堆区和栈区的区别"></a>堆区和栈区的区别</h2><h3 id="管理分配方式"><a href="#管理分配方式" class="headerlink" title="管理分配方式"></a>管理分配方式</h3><p>   栈的分配和释放是由编译器完成的，栈的动态分配由<code>alloca()</code>函数完成，无需程序员手工控制；</p>
<p>   堆都是程序中由<code>malloc()</code>函数动态申请分配并由<code>free()</code>函数释放的，申请释放工作由程序员控制，容易产生内存泄漏。</p>
<h3 id="空间大小"><a href="#空间大小" class="headerlink" title="空间大小"></a>空间大小</h3><p>   栈是向低地址扩展的数据结构，是一块连续的内存区域。栈顶的地址和栈的最大容量是系统预先规定好的，当超出申当申请的空间超过栈的剩余空间时，将提示溢出，用户能从栈获得的空间较小。在 WINDOWS 下，栈的大小是2M；</p>
<p>   堆是向高地址扩展的数据结构，是不连续的内存区域。因为系统是用链表来存储空闲内存地址的，且链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间较灵活，也较大。</p>
<h3 id="是否产生碎片"><a href="#是否产生碎片" class="headerlink" title="是否产生碎片"></a>是否产生碎片</h3><p>   对于堆来讲，频繁的malloc/free（new/delete）势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低（虽然程序在退出后操作系统会对内存进行回收管理）；</p>
<p>   对于栈来讲，则不会存在这个问题。</p>
<h3 id="增长方向"><a href="#增长方向" class="headerlink" title="增长方向"></a>增长方向</h3><p>   堆的增长方向是向上的，即向着内存地址增加的方向；</p>
<p>   栈的增长方向是向下的，即向着内存地址减小的方向。</p>
<h3 id="分配效率"><a href="#分配效率" class="headerlink" title="分配效率"></a>分配效率</h3><p>   栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行。系统自动分配，速度较快，程序员是无法控制的；</p>
<p>   堆则是C函数库提供的，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大的空间，如果没有足够大的空间（可能是由于内存碎片太多），就有需要操作系统来重新整理内存空间，这样就有机会分到足够大小的内存，然后返回。由<code>new</code>分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。</p>
<h3 id="申请后系统的响应"><a href="#申请后系统的响应" class="headerlink" title="申请后系统的响应"></a>申请后系统的响应</h3><p>   栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p>   堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的<code>delete</code>语句才能正确的释放本内存空间。由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>
<h3 id="存储的内容"><a href="#存储的内容" class="headerlink" title="存储的内容"></a>存储的内容</h3><p>   堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</p>
<p>   栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量（静态变量不入栈）。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。栈中的内存是在程序编译完成以后就可以确定的，不论占用空间大小，还是每个变量的类型。</p>
<h3 id="防止越界"><a href="#防止越界" class="headerlink" title="防止越界"></a>防止越界</h3><p>   无论是堆还是栈，都要防止越界现象的发生（除非故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生意想不到的结果。debug相当困难。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS分词]]></title>
      <url>http://www.liugangqiang.com/2016/10/25/iOS%E5%88%86%E8%AF%8D/</url>
      <content type="html"><![CDATA[<p>最近锤子科技发布新手机，手机推出重大功能分词（Big Bang），其实 iOS 拥有分词的 API，代码如下</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (NSArray *)stringTokenizerWithWord:(NSString *)word &#123;</span><br><span class="line">    NSMutableArray *keyWords = [NSMutableArray <span class="keyword">new</span>];</span><br><span class="line">    CFStringTokenizerRef ref = CFStringTokenizerCreate(<span class="literal">NULL</span>, (__bridge CFStringRef)word, CFRangeMake(<span class="number">0</span>, word.length),kCFStringTokenizerUnitWord,<span class="literal">NULL</span>);</span><br><span class="line">    CFRange range;</span><br><span class="line">    NSString *keyWord;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        CFStringTokenizerAdvanceToNextToken(ref);</span><br><span class="line">        range = CFStringTokenizerGetCurrentTokenRange(ref);</span><br><span class="line">        <span class="keyword">if</span> (range.length == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        keyWord = [word substringWithRange:NSMakeRange(range.location, range.length)];</span><br><span class="line">        [keyWords addObject:keyWord];</span><br><span class="line">    &#125; <span class="keyword">while</span> (range.length &gt; <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> keyWords;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CocoaPods安装和使用]]></title>
      <url>http://www.liugangqiang.com/2016/07/04/CocoaPods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="CocoaPods-简介"><a href="#CocoaPods-简介" class="headerlink" title="CocoaPods 简介"></a>CocoaPods 简介</h2><p>在 iOS 应用的开发过程中，经常会使用到第三方的开源类库，例如AFNetWorking、SDWebimage 等等。通常，我们会把第三方的框架从网上下载下来， 再拖入到我们的项目中，但是这样一个一个的操作十分繁琐，而且存在<strong>第三方库更新不及时，不易集中管理的问题</strong>。<br><a href="https://cocoapods.org" target="_blank" rel="external">CocoaPods</a> 是为解决此类问题而产生的第三方类库管理工具。它将第三方库集中到一起管理，只需要一行终端命令就第三方库进行安装、更新等处理。绝大部分有名的开源类库，都支持CocoaPods。作为iOS开发程序员，掌握 CocoaPods 的使用时必不可少的基本技能之一。</p>
<a id="more"></a>
<h2 id="CocoaPods-的安装"><a href="#CocoaPods-的安装" class="headerlink" title="CocoaPods 的安装"></a>CocoaPods 的安装</h2><h3 id="安装配置-Ruby-环境"><a href="#安装配置-Ruby-环境" class="headerlink" title="安装配置 Ruby 环境"></a>安装配置 Ruby 环境</h3><h4 id="检查-Ruby-环境（安装）"><a href="#检查-Ruby-环境（安装）" class="headerlink" title="检查 Ruby 环境（安装）"></a>检查 Ruby 环境（安装）</h4><p>CocoaPods 是使用 Ruby 语言编写，所以安装之前需要先安装 Ruby 环境。默认情况下，Mac OS X 系统已经安装好 Ruby。在终端直接使用以下命令，确认系统系统 Ruby 的版本信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ruby --version</span><br><span class="line">或者 </span><br><span class="line">$ ruby --v</span><br><span class="line"></span><br><span class="line">// 输出版本信息大致如下</span><br><span class="line">// ruby 2.0.0p648 (2015-12-16 revision 53162) [universal.x86_64-darwin15]</span><br></pre></td></tr></table></figure></p>
<p>如果没有安装 Ruby，<a href="https://github.com/ruby-china/ruby-china/wiki/Mac-OS-X-上安装-Ruby" target="_blank" rel="external">点击这里进行安装</a></p>
<h4 id="更换-Ruby-源链接"><a href="#更换-Ruby-源链接" class="headerlink" title="更换 Ruby 源链接"></a>更换 Ruby 源链接</h4><p>Ruby 默认的源为 <code>https://rubygems.org</code>，因为这个源在墙外，直接访问这个源使用 CocoaPods 速度会非常慢（很可能安装失败）。<del>但是，我们可以使用淘宝的 Ruby 镜像来访问 CocoaPods</del>（淘宝镜像服务已经停止，由<code>https://gems.ruby-china.org/</code>接管）。</p>
<p>查看 Ruby 源。如果网址为 <del><code>https://ruby.taobao.org/</code></del>（<code>https://gems.ruby-china.org/</code>），则说明之前已经进行过更换，可以直接安装 CocoaPods。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span><br><span class="line">// *** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">// https://rubygems.org/</span><br></pre></td></tr></table></figure></p>
<p>移除 Ruby 源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --remove https://rubygems.org/</span><br><span class="line">// https://rubygems.org/ removed from sources</span><br></pre></td></tr></table></figure></p>
<p>添加新的 Ruby 源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -a https://gems.ruby-china.org/</span><br><span class="line">// https://gems.ruby-china.org/ added to sources</span><br><span class="line"></span><br><span class="line">// $ gem sources -a https://ruby.taobao.org/ 已废弃</span><br></pre></td></tr></table></figure></p>
<p>检查是否添加成功<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span><br></pre></td></tr></table></figure></p>
<p>在终端中显示如下结果时，说明更换成功<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//gems.ruby-china.org/</span></span><br></pre></td></tr></table></figure></p>
<h3 id="安装-CocoaPods"><a href="#安装-CocoaPods" class="headerlink" title="安装 CocoaPods"></a>安装 CocoaPods</h3><p>在终端运行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure></p>
<p>运行之后，需要输入电脑的密码，并且没有密码输入位数的提醒。密码输入正确之后就进行安装了，安装可能需要很长时间，耐心等待。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Fetching: cocoapods-core<span class="number">-1.0</span><span class="number">.1</span>.gem (<span class="number">100</span>%)</span><br><span class="line">Successfully installed cocoapods-core<span class="number">-1.0</span><span class="number">.1</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Parsing documentation <span class="keyword">for</span> cocoapods<span class="number">-1.0</span><span class="number">.1</span></span><br><span class="line">Installing ri documentation <span class="keyword">for</span> cocoapods<span class="number">-1.0</span><span class="number">.1</span></span><br><span class="line"><span class="number">13</span> gems installed</span><br></pre></td></tr></table></figure></p>
<p>出现类似这样的提示，就说明 CocoaPods 安装成功了</p>
<h2 id="CocoaPods-的使用"><a href="#CocoaPods-的使用" class="headerlink" title="CocoaPods 的使用"></a>CocoaPods 的使用</h2><h3 id="创建-Podfile-文件"><a href="#创建-Podfile-文件" class="headerlink" title="创建 Podfile 文件"></a>创建 Podfile 文件</h3><p>在终端定位到需要使用 CocoaPods 的项目的工程目录，使用命令创建一个 Podfile 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /Users/new/Desktop/YourProject</span><br><span class="line">$ pod init</span><br></pre></td></tr></table></figure></p>
<p>出现如下文件<br><img src="/uploads/Cocopods-image1.png" alt=""><br>创建成功</p>
<h3 id="编辑-Podfile-文件"><a href="#编辑-Podfile-文件" class="headerlink" title="编辑 Podfile 文件"></a>编辑 Podfile 文件</h3><p>打开 Podfile 文件<br><img src="/uploads/Cocopods-image2.png" alt=""><br>带<code>#</code>的为注释</p>
<ol>
<li>删除掉第二行的<code>#</code>,为你的项目设置最低支持的 iOS 版本。</li>
<li>在 <code>target &#39;YourProject&#39; do</code> 和 <code>end</code> 之间输入你想导入的框架，如 AFNetworking:<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target 'YourProject' do</span><br><span class="line">  # Uncomment this line if you're using Swift or would like to use dynamic frameworks</span><br><span class="line">  # use_frameworks!</span><br><span class="line">  # Pods for YourProject</span><br><span class="line">pod ‘AFNetworking’</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="执行命令安装-CocoaPods"><a href="#执行命令安装-CocoaPods" class="headerlink" title="执行命令安装 CocoaPods"></a>执行命令安装 CocoaPods</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod install</span><br></pre></td></tr></table></figure>
<p>等待执行完毕，即可完成 CocoaPods 的安装。</p>
<p>另外，也可以使用更新 CocoaPods 版本并进行安装<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod update</span><br></pre></td></tr></table></figure></p>
<p><code>pod install</code> 和 <code>pod update</code>执行过程中都会更新 podpec 的索引，有时速度会很慢，为了提高速度，可以输入如下命令，在不更新索引的情况下执行命令：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod install --no-repo-update</span><br></pre></td></tr></table></figure></p>
<p>也可以在每条命令后加 <code>--verbose</code> 显示详细的命令执行内容</p>
<h3 id="项目打开方式改变"><a href="#项目打开方式改变" class="headerlink" title="项目打开方式改变"></a>项目打开方式改变</h3><p>安装成功后，项目目录下回多出几个文件，以后打开文件要使用箭头所指白色的<code>.xcworkspace</code>文件，不再使用蓝色的<code>.xcodeproj</code>文件。<br><img src="/uploads/Cocopods-image3.png" alt=""><br>项目打开之后，层级结构如下<br><img src="/uploads/Cocopods-image5.png" alt=""><br>上边的是我们原先的项目代码，下边的是 CocoaPods 文件以及它导入的第三方库。</p>
<p>需要注意的是，要引用 CocoaPods 导入的第三方库，要使用 <code>&lt;&gt;</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;AFNetworking.h&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="添加或者删除第三方库"><a href="#添加或者删除第三方库" class="headerlink" title="添加或者删除第三方库"></a>添加或者删除第三方库</h3><p>CocoaPods 安装完成后，再安装或者删除第三方库，只需要编辑 Podfile 文件添加或者删除对应的引用，然后执行<code>pod install</code> 或者 <code>pod update</code>命令即可。<br><img src="/uploads/Cocopods-image4.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://www.liugangqiang.com/2016/06/17/hello-world/</url>
      <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>Welcome to <em>The Corner Grocery ! I`m </em>刚刚_ .</p>
<a id="more"></a>
]]></content>
    </entry>
    
  
  
</search>
